## Chapter 1
컴퓨터의 핵심이 어떻게 작동하는지에 대한 기본부터 시작해 보겠습니다.
### 컴퓨터의 설계 방식
CPU는 모든 연산을 담당한다. CPU가 실행하는 "명령어"는 그저 0과 1의 이진 데이터이다. 실행 중인 명령을 나타내는 1바티으 또는 2바이트와 명령을 실행하는 데 필요한 데이터가 뒤따른다. 우리가 기계어라고 부르는 것은 일련의 이진 명령어가 연속적으로 나열된 것에 지나지 않는다. 어셈블리는 인간이 원시 비트보다 읽고 쓰기 쉬운 기계어 코드를 읽고 쓰는 데 유용한 구문이다. 이는 항상 CPU가 읽는 방법을 알고 있는 바이너리로 컴파일 된다.

![image](https://cpu.land/images/assembly-to-machine-code-translation.png)

> [!info]
> 위의 예에서와 같이 명령어가 기계어 코드에서 항상 1:1로 표시되는 것은 아니다.
> 예를 들어, `05 00 02 00 00`은  `add eax, 512`로 번역된다.
> 
> 첫 번째 바이트(`05`)는 EAX 레지스터를 32비트 숫자에 추가하는 것을 구체적으로 나타내는 명령이다. 나머지 바이트는 리틀 엔디언 바이트 순서로 512(`0x200`)이다.

RAM은 컴퓨터의 주기억 장치로, 컴퓨터에서 실행되는 프로그램에서 사용하는 모든 데이터를 저장하는 대규모 다목적 공간이다. 프로그램 코드와 OS의 핵심 코드도 포함된다. CPU는 항상 RAM에서 직접 기계어 코드를 읽으며, RAM에 로드되지 않으면 코드를 실행할 수 없다.

CPU는 다음 명령어를 가져올 RAM의 위치를 가리키는 명령어 **포인터**를 저장한다. 각 명령어를 실행한 후 CPU는 포인터를 이동하고 반복한다. 이것이 **Fetch-Execute Cycle**이다.

![fetch-execute](https://cpu.land/images/fetch-execute-cycle.png)

명령어를 실행한 후 포인터는 RAM의 명령어 바로 뒤로 이동하여 다음 명령어를 가리킨다. 명령어 포인터는 메모리에 저장된 순서대로 기계어 코드를 실행하면서 계속 진행된다. 일부 명령어는 명령어 포인터에게 다른 곳으로 점프하거나 특정 조건에 따라 다른 위치로 점프하도록 지시할 수 있다. 이를 통해 재사용 가능한 코드와 조건부 논리가 가능해진다.

이 명령어 포인터는 **레지스터**에 저장된다. 레지스터는 CPU가 읽고 쓰는 속도가 매우 빠른 작은 스토리지 버킷이다. 각 CPU 아키텍처에는 계산 중 임시 