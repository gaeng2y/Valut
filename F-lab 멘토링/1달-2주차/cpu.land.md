## Chapter 1
컴퓨터의 핵심이 어떻게 작동하는지에 대한 기본부터 시작해 보겠습니다.
### 컴퓨터의 설계 방식
CPU는 모든 연산을 담당한다. CPU가 실행하는 "명령어"는 그저 0과 1의 이진 데이터이다. 실행 중인 명령을 나타내는 1바티으 또는 2바이트와 명령을 실행하는 데 필요한 데이터가 뒤따른다. 우리가 기계어라고 부르는 것은 일련의 이진 명령어가 연속적으로 나열된 것에 지나지 않는다. 어셈블리는 인간이 원시 비트보다 읽고 쓰기 쉬운 기계어 코드를 읽고 쓰는 데 유용한 구문이다. 이는 항상 CPU가 읽는 방법을 알고 있는 바이너리로 컴파일 된다.

![image](https://cpu.land/images/assembly-to-machine-code-translation.png)

> [!info]
> 위의 예에서와 같이 명령어가 기계어 코드에서 항상 1:1로 표시되는 것은 아니다.
> 예를 들어, `05 00 02 00 00`은  `add eax, 512`로 번역된다.
> 
> 첫 번째 바이트(`05`)는 EAX 레지스터를 32비트 숫자에 추가하는 것을 구체적으로 나타내는 명령이다. 나머지 바이트는 리틀 엔디언 바이트 순서로 512(`0x200`)이다.

RAM은 컴퓨터의 주기억 장치로, 컴퓨터에서 실행되는 프로그램에서 사용하는 모든 데이터를 저장하는 대규모 다목적 공간이다. 프로그램 코드와 OS의 핵심 코드도 포함된다. CPU는 항상 RAM에서 직접 기계어 코드를 읽으며, RAM에 로드되지 않으면 코드를 실행할 수 없다.

CPU는 다음 명령어를 가져올 RAM의 위치를 가리키는 명령어 **포인터**를 저장한다. 각 명령어를 실행한 후 CPU는 포인터를 이동하고 반복한다. 이것이 **Fetch-Execute Cycle**이다.

![fetch-execute](https://cpu.land/images/fetch-execute-cycle.png)

명령어를 실행한 후 포인터는 RAM의 명령어 바로 뒤로 이동하여 다음 명령어를 가리킨다. 명령어 포인터는 메모리에 저장된 순서대로 기계어 코드를 실행하면서 계속 진행된다. 일부 명령어는 명령어 포인터에게 다른 곳으로 점프하거나 특정 조건에 따라 다른 위치로 점프하도록 지시할 수 있다. 이를 통해 재사용 가능한 코드와 조건부 논리가 가능해진다.

이 명령어 포인터는 **레지스터**에 저장된다. 레지스터는 CPU가 읽고 쓰는 속도가 매우 빠른 작은 스토리지 버킷이다. 각 CPU 아키텍처에는 계산 중 임시 값 저장부터 프로세서 구성에 이르기까지 모든 작업에 사용되는 고정된 레지스터 세트가 있다.

일부 레지스터는 이전 다이어그램의 `ebx`와 같은 기계어 코드에서 직접 액세스할 수 있다.

다른 레지스터는 CPU 내부에서만 사용되지만 특수 명령어를 사용하여 업데이트하거나 읽을 수 있는 경우가 많다. 한 가지 예로 직접 읽을 수는 없지만 점프 명령어 등을 사용하여 업데이트할 수 있는 명령어 포인터가 있다.
### 프로세서는 순진하다.
실행할 준비가 끝나면 파일 어딘가에 기계어 코드가 있다. 운영 체제는 이를 RAM에 로드하고 CPU에 명령 포인터를 RAM의 해당 위치로 점프하도록 지시한다. CPU는 평소와 같이 fetch-execute 사이클을 계속 실행하므로 프로그램이 실행되기 시작한다.

![iamge3](https://cpu.land/images/instruction-pointer.png)

CPU에서는 현재 명령어 포인터와 약간의 내부 상태만 볼 수 있다. 프로세스는 CPU가 기본적으로 이해하거나 추적하는 것이 아니라 전적으로 운영 체제 추상화이다.

1. CPU가 다중 처리에 대해 모르고 명령을 순차적으로 실행하는 경우 실행 중인 프로그램이 무엇이든 내부에 갇히지 않는 이유는? 어떻게 여러 프로그램을 동시에 실행할 수 있지?
2. 프로그램이 CPU에서 직접 실행되고 CPU가 RAM에 직접 액세스할 수 있다면 왜 코드가 다른 프로세스의 메모리에 액세스할 수 없거나 커널을 금지할 수 없을까?
3. 말하자면, 모든 프로세스가 명령을 실행하고 컴퓨터에 어떤 작업도 수행하지 못하도록 방지하는 메커니즘은 무엇? syscall은 뭐지?

이제 첫 번째 토끼 굴을 통과하여 시스템 콜과 보안 링으로 가득 찬 땅으로 도약할 시간입니다.

> [!question]
> 커널이란?
> 운영 체제는 컴퓨터에서 실행되고 모든 기본 기능을 작동시키는 소프트웨어 모음이다. "기본 사항"은 매우 일반적인 용어이고 "운영 체제"도 마찬가지다.
> 
> 그러나 커널은 운영 체제의 핵심이다. 컴퓨터를 부팅하면 명령 포인터가 프로그램 어딘가에서 시작된다. 그 프로그램이 커널이다. 커널은 컴퓨터의 메모리, 주변 장치 및 기타 리소스에 거의 모든 액세스 권한을 가지며 컴퓨터에 설치된 소프트웨어 실행을 담당한다. 

### 모두를 지배할 두 개의 반지
프로세서가 수행할 수 있는 모드(때때로 권한 수준 또는 링이라고 함)에 따라 프로세서가 수행할 수 있는 작업이 제어된다. 최신 아키텍처에는 커널/수퍼바이저 모드와 사용자 모드라는 두 가지 이상의 옵션이 있다. 아키텍처는 두 가지 이상의 모드를 지원할 수 있지만 요즘에는 커널 모드와 사용자 모드만 일반적으로 사용된다.

커널 모드에서는 무엇이는 가능하다. CPU는 지원되는 모든 명령을 실행하고 모든 메모리에 액세스할 수 있다. 사용자 모드에서는 명령어와 하위 집합만 허용되고 I/O 및 메모리 액세스가 제한되며 많은 CPU 설정이 잠겨있다. 일반적으로 커널과 드라이버는 커널 모드에서 실행되고 응용 프로그램은 유저 모드에서 실행된다.

프로세서는 커널 모드에서 시작된 후 프로그램을 실행하기 전에 커널은 유저 모드로의 전환을 시작한다.

![image4](https://cpu.land/images/kernel-mode-vs-user-mode.png)
실제 아키텍처에서 프로세서 모드가 어떻게 나타나는지에 대한 예: x86-64에서 현재 권한 수준(CPL)은 `cs(코드 세그먼트)`라는 레지스터에서 읽을 수 있다. 특히 CPL은 `cs` 레지스터의 최하위 비트 2개에 포함되어 있다. 이 두 비트는 x86-64의 네 가지 가능한 링을 저장할 수 있다. 링 0은 커널 모드이고 링3은 유저 모드이다. 링 1과 2는 드라이버 실행을 위해 설계되었지만 소수의 오래된 운영 체제에서만 사용된다. 만약 CPL 최하위 두 비트가 `11`이면 CPU는 링 3: 유저모드에서 실행 중이다.

### Syscall이란 무엇인가?
프로그램은 컴퓨터에 대한 전체 액세스 권한을 신뢰할 수 없기 때문에 유저 모드에서 실행된다. 유저 모드는 해당 작업을 수행하여 대부분의 컴퓨터에 대한 액세스를 방지한다. 하지만 프로그램은 I/O에 액세스하고, 메모리를 할당하고, 어떻게든 OS와 상호 작용할 수 있어야 한다! 이를 위해 유저 모드에서 실행되는 소프트웨어는 OS 커널에 도움을 요청해야 한다. 그런 다음 OS는 프로그램이 악의적인 작업을 수행하지 못하도록 자체 보안 보호 기능을 구현할 수 있다.

OS와 상호 작용하는 코드를 보거나 작성한 적있다면 `open`, `read`, `fork` 그리고 `exit`와 같은 기능을 인식할 것이다. 몇 가지 추상화 계층 아래에서 이러한 기능은 모두 System call을 사용하여 OS에 도움을 요청한다. Syscall은 프로그램이 사용자 공간에서 커널 공간으로 전환을 시작하고 프로그램 코드에서 OS 코드로 점프할 수 있도록 하는 특별한 절차이다.

사용자 공간에서 커널 공간으로의 제어 전송은 [**소프트웨어 인터럽트**](https://en.wikipedia.org/wiki/Interrupt#Software_interrupts)라는 프로세서 기능을 사용하여 수행된다.

1. 부팅 프로세스 중에 OS는 인터럽트 벡터 테이블(IVT, x86-64에서는 이를 인터럽트 설명자 테이블이라고도 함)이라는 테이블을 RAM에 저장하고 이를 CPU에 등록한다. IVT는 인터럽트 번호를 핸들러 코드 포인터에 매핑한다.
   ![image5](https://cpu.land/images/interrupt-vector-table.png)
2. 그런 다음 유저 영역 프로그램을 IVT에서 주어진 인터럽트 번호를 조회하고 커널 모드로 전환한 다음 명령 포인터를 IVT에 저장된 메모리 주소로 점프하도록 프로세서에 지시하는 INT와 같은 명령을 사용할 수 있다.

이 커널 코드가 완료되면 IRET와 같은 명령어를 사용하여 CPU에 사용자 모드로 다시 전환하고 인터럽트가 트리거되었을 때의 명령어 포인터를 반환하도록 지시한다.
(궁금하시다면 Linux에서 시스템 호출에 사용되는 인터럽트 ID는 `0x80`입니다. Michael Kerrisk의 온라인 맨페이지 디렉토리에서 Linux 시스템 호출 목록을 읽을 수 있습니다.))

### W