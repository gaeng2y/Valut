작업을 제 시간에 완료하기 위해 프로세스/작업 일정을 수립합니다. **CPU 스케줄링은** 한 프로세스가 CPU를 사용하는 동안 다른 프로세스는 I/O 등의 자원을 사용할 수 없어 지연(대기)하여 CPU를 최대한 활용할 수 있도록 하는 프로세스입니다. 

**CPU 스케줄링의 목적은 시스템을 보다 효율적이고 빠르며 공정하게 만드는 것입니다.**

## 프로세스란?
컴퓨팅에서 프로세스는 **하나 이상의 스레드에 의해 실행되는 컴퓨터 프로그램의 인스턴스**다. OS에 따라 프로세스는 명령을 동시에 실행하는 여러 실행 스레드로 구성될 수 있습니다.
## 효율적인 작업을 위해 프로세스 메모리는 어떻게 사용됩니까?
프로세스 [메모리는](https://www.geeksforgeeks.org/memory-layout-of-c-program/) 효율적인 작동을 위해 4개의 섹션으로 구분됩니다.

- 텍스트 **카테고리는 프로그램 실행 시 고정 저장소에서 읽어오는 통합 프로그램 코드로 구성됩니다.
- 데이터 **클래스는** 전역 변수와 정적 변수로 구성되며 주요 작업 이전에 배포 및 실행됩니다.
- [힙은](http://www.geeksforgeeks.org/binary-heap/) 유연하거나 동적 메모리 할당에 사용되며 new, delete, malloc, free 등에 대한 호출로 관리됩니다.
- 스택 [은](https://www.geeksforgeeks.org/stack-data-structure/) 지역 변수에 사용됩니다. 스택의 공간은 선언될 때 지역 변수를 위해 예약되어 있습니다.

![image1](https://media.geeksforgeeks.org/wp-content/uploads/memoryLayoutC.jpg)

## 프로세스 스케줄링이란 무엇입니까?
프로세스 스케줄링은 **프로세스 관리자가 CPU에서 활성 프로세스를 제거하고 특정 전략에 따라 다른 프로세스를 선택하는 프로세스**다.

프로세스 스케줄링은 다중 프로그래밍 애플리케이션의 필수적인 부분이다. 이러한 운영 체제에서는 한 번에 둘 이상의 프로세스를 사용 가능한 메모리에 로드할 수 있으며 로드된 공유 CPU 프로세스는 반복 시간을 사용한다.

[프로세스 스케줄러](https://www.geeksforgeeks.org/process-schedulers-in-operating-system/) 에는 세 가지 유형이 있습니다 .

- 장기 또는 작업 스케줄러
- 단기 또는 CPU 스케줄러 
- 중기 스케줄러

## 왜 우리는 프로세스 일정을 잡아야 하나요?

- **스케줄링은** 다양한 컴퓨터 환경에서 중요하다. 가장 중요한 영역 중 하나는 어떤 프로그램이 CPU에서 작동할지 스케줄링하는 것이다. 이 작업은 컴퓨터의 운영 체제(OS)에 의해 처리되며 프로그램을 구성할 수 있는 다양한 방법이 있습니다.
- **프로세스 스케줄링은** OS가 각 프로세스에 CPU 시간을 할당할 수 있게 해준다. 프로세스 스케줄링 시스템을 사용하는 또 다른 중요한 이유는 CPU를 항상 바쁘게 하기 때문이다. 이를 통해 프로그램에 대한 응답 시간을 줄일 수 있습니다.
- 작동해야 하는 수백 개의 프로그램이 있을 수 있다는 점을 고려할 때, OS는 프로그램을 실행하고, 중지하고, 다른 프로그램으로 전환해야 합니다. OS가 CPU에서 다른 시스템을 실행하도록 구성하는 방식을 "[컨텍스트 스위칭](https://www.geeksforgeeks.org/difference-between-swapping-and-context-switching/)"이라고 합니다. OS가 제공된 CPU 안팎에서 컨텍스트 전환 프로그램을 유지한다면, 사용자에게 자신이 원하는 모든 프로그램을 한 번에 실행할 수 있다는 까다로운 아이디어를 줄 수 있다.
- 이제 우리는 주어진 CPU에서 1개의 프로그램을 실행할 수 있고, 운영 체제를 변경하고 컨텍스트 스위치를 사용하여 다른 프로그램을 제거할 수 있다는 것을 알고 있습니다. 필요한 프로그램을 어떻게 선택해야 할까요?
- 그게 **스케줄링이** 들어오는 곳이야! 먼저, 당신은 "끝까지의 시간"과 같은 것을 말하면서 지표를 결정합니다. 우리는 이 메트릭을 "함수가 완료될 때까지 시스템에 들어가는 시간 간격"으로 정의할 것이다. 둘째, 당신은 지표를 줄이는 지표를 결정합니다. 우리는 우리의 일이 가능한 한 빨리 끝나기를 바란다.
## CPU 스케줄링 알고리즘의 필요성은 무엇인가요?

****CPU 스케줄링은**** 다른 프로세스가 일시 중지되는 동안 사용할 CPU를 소유할 프로세스를 결정하는 과정이다. CPU 스케줄링의 주요 기능은 CPU가 유휴 상태로 유지될 때마다 OS가 즉시 사용 가능한 라인에서 사용할 수 있는 프로세스 중 적어도 하나를 선택하도록 하는 것입니다.

[멀티프로그래밍에서](https://www.geeksforgeeks.org/difference-between-multitasking-multithreading-and-multiprocessing/), 장기 스케줄러가 여러 I/O 바인딩 프로세스를 선택하면 대부분의 경우 CPU는 유휴 상태로 유지됩니다. 효과적인 프로그램의 기능은 자원 활용을 개선하는 것이다.

대부분의 운영 체제가 성능에서 대기 상태로 변경하면 항상 시스템에 실패할 가능성이 있을 수 있습니다. 따라서 이러한 과잉을 최소화하기 위해, OS는 CPU를 최대한 활용하고 교착 상태의 가능성을 피하기 위해 작업을 예약해야 합니다.

[멀티프로그래밍에서](https://www.geeksforgeeks.org/difference-between-multitasking-multithreading-and-multiprocessing/), 장기 스케줄러가 여러 I/O 바인딩 프로세스를 선택하면 대부분의 경우 CPU는 유휴 상태로 유지됩니다. 효과적인 프로그램의 기능은 자원 활용을 개선하는 것이다.

대부분의 운영 체제가 성능에서 대기 상태로 변경하면 항상 시스템에 실패할 가능성이 있을 수 있습니다. 따라서 이러한 과잉을 최소화하기 위해, OS는 CPU를 최대한 활용하고 교착 상태의 가능성을 피하기 위해 작업을 예약해야 합니다.

### ****프로세스 스케줄링 알고리즘의 목표:****

- 최대 수준의 CPU 활용. ****CPU를 가능한 한 바쁘게 유지하세요****.
- ****CPU의 할당은 공정해야 한다****.
- ****처리량은 최대여야 합니다****. 즉, 시간 단위당 실행을 완료하는 프로세스의 수는 최대화되어야 한다.
- ****최소 처리 시간****, 즉 실행을 완료하는 데 걸리는 시간이 최소여야 합니다.
- ****최소한의 대기 시간이**** 있어야 하며 그 과정은 준비된 대기열에서 굶어죽어서는 안 된다.
- ****최소**** ****응답 시간.**** 그것은 프로세스가 첫 번째 응답을 생성하는 시간이 가능한 한 적어야 한다는 것을 의미한다

## CPU 스케줄링 알고리즘에서 처리해야 할 다른 용어는 무엇인가요?

- ****도착 시간:**** 프로세스가 준비된 대기열에 도착하는 시간.
- ****완료 시간:**** 프로세스가 실행을 완료하는 시간.
- ****버스트 시간:**** CPU 실행 프로세스에 필요한 시간.
- ****턴어라운드 시간:**** 완료 시간과 도착 시간의 시차.

> 회전 시간 = 완료 시간 – 도착 시간

- ****대기 시간(W.T):**** 회전 시간과 버스트 시간의 시간 차이.

> 대기 시간 = 회전 시간 – 버스트 시간

## CPU 스케줄링 알고리즘을 설계하는 동안 주의해야 할 것들?

다른 ****CPU 스케줄링 알고리즘은**** 다른 구조를 가지고 있으며 특정 알고리즘의 선택은 다양한 요인에 따라 달라집니다. CPU 스케줄링 알고리즘을 비교하기 위해 많은 조건이 제기되었다.

기준은 다음을 포함한다:

- ****CPU 활용:**** 모든 CPU 알고리즘의 주요 목적은 CPU를 가능한 한 바쁘게 유지하는 것이다. 이론적으로, CPU 사용량은 0에서 100까지 다양할 수 있지만 실시간 시스템에서는 시스템 부하에 따라 40에서 90%까지 다양합니다.
- ****처리량:**** 평균 CPU 성능은 각 장치 동안 수행되고 완료된 프로세스의 수입니다. 이것은 처리량이라고 불린다. 출력은 프로세스의 길이나 기간에 따라 달라질 수 있습니다.
- ****턴 라운드 타임:**** 특정 프로세스의 경우, 중요한 조건은 해당 프로세스를 수행하는 데 걸리는 시간입니다. 프로세스 전달 시간부터 완료 시간까지 경과한 시간은 변환 시간으로 알려져 있다. 변환 시간은 메모리 액세스를 기다리고, 줄을 서서 기다리고, CPU를 사용하고, I/O를 기다리는 데 소요되는 시간입니다.
- ****대기 시간:**** 스케줄링 알고리즘은 수행을 시작하면 프로세스를 완료하는 데 필요한 시간에 영향을 미치지 않습니다. 그것은 프로세스의 대기 시간, 즉 준비된 대기열에서 대기 프로세스에 소요된 시간에만 영향을 미칩니다.
- ****응답 시간:**** 협업 시스템에서, 턴어답 시간은 최선의 선택이 아니다. 그 과정은 일찍 무언가를 생성하고 이전 결과가 사용자에게 공개되는 동안 새로운 결과를 계속 계산할 수 있다. 따라서 또 다른 방법은 첫 번째 응답이 발행될 때까지 신청 절차를 제출하는 데 걸리는 시간이다. 이 측정은 응답 시간이라고 불린다

## CPU 스케줄링 알고리즘의 다른 유형은 무엇인가요?

주로 두 가지 유형의 스케줄링 방법이 있습니다:

- [선점형 스케줄링](https://www.geeksforgeeks.org/preemptive-and-non-preemptive-scheduling/): 선점형 스케줄링은 프로세스가 실행 상태에서 준비 상태로 또는 대기 상태에서 준비 상태로 전환할 때 사용됩니다.
- [비선점형 스케줄링](https://www.geeksforgeeks.org/preemptive-and-non-preemptive-scheduling/): 비선점형 스케줄링은 프로세스가 종료되거나 프로세스가 실행 상태에서 대기 상태로 전환될 때 사용됩니다.
![image2](https://media.geeksforgeeks.org/wp-content/uploads/20220525174157/UntitledDiagram12.jpg)

알고리즘에 대해
	* 스타베이션
	* 우선순위 인버젼
	* 컨텍스트 스위치 많이 발생
	* Thread Explrotion

CPU 스케줄링은 컴퓨터의 운영 체제가 여러 프로세스 또는 스레드에게 CPU 시간을 효율적으로 분배하는 방법을 말합니다. 다양한 스케줄링 알고리즘을 사용하여 CPU 자원을 최적화하고 시스템 성능을 극대화합니다. 주요 목표는 공정성, 처리량, 대기 시간, 응답 시간 등을 최적화하는 것입니다.

#### 주요 스케줄링 알고리즘

1. **FCFS (First-Come, First-Served):**
    - 가장 먼저 도착한 프로세스부터 처리하는 방식.
    - 단순하지만, 비효율적일 수 있음(긴 프로세스가 먼저 도착하면 전체 대기 시간 증가).
2. **SJF (Shortest Job First):**
    - 실행 시간이 가장 짧은 프로세스부터 처리.
    - 최적의 대기 시간을 제공하지만, 실행 시간을 미리 알아야 함.
4. **RR (Round Robin):**
    - 각 프로세스가 일정한 시간 동안 CPU를 번갈아가며 사용.
    - 공정성을 보장하지만, 문맥 교환이 잦아질 수 있음.
5. **Priority Scheduling:**
    - 우선순위가 높은 프로세스부터 처리.
    - 우선순위가 낮은 프로세스가 오래 대기할 수 있음.
6. **Multilevel Queue Scheduling:**
    - 여러 개의 큐를 사용해 프로세스를 그룹화하고 각 큐에 대해 다른 스케줄링 알고리즘 적용.
    - 시스템 자원과 프로세스 특성에 따라 유연하게 대응 가능.
7. **Multilevel Feedback Queue:**
    - 프로세스의 행동에 따라 다른 큐로 이동시켜 동적인 스케줄링 제공.

### 다양한 CPU 스케줄링 알고리즘 간의 비교

다음은 다른 CPU 스케줄링 알고리즘 간의 간략한 비교입니다:

| 알고리즘      | 할당은                                                               | 복잡성                                | 평균 대기 시간 (AWT)             | 선점  | 굶주림 | 성능                     |
| --------- | ----------------------------------------------------------------- | ---------------------------------- | -------------------------- | --- | --- | ---------------------- |
| FCFS      | 프로세스의 도착 시간에 따라, CPU가 할당된다.                                       | 간단하고 구현하기 쉽다.                      | 큰.                         | 아니  | 아니  | 느린 성능                  |
| SJF       | 가장 낮은 CPU 버스트 시간(BT)을 기준으로 합니다.                                   | FCFS보다 더 복잡한                       | FCFS보다 작은                  | 아니  | 네   | 최소 평균 대기 시간            |
| LJFS      | 가장 높은 CPU 버스트 시간(BT)을 기준으로                                        | FCFS보다 더 복잡한                       | 도착 시간, 프로세스 크기 등 일부 조치에 따라 | 아니  | 네   | 큰 처리 시간                |
| LRTF      | LJFS와 마찬가지로 CPU 할당은 가장 높은 CPU 버스트 시간(BT)을 기반으로 합니다. 하지만 그건 선제적이야. | FCFS보다 더 복잡한                       | 도착 시간, 프로세스 크기 등 일부 조치에 따라 | 네   | 네   | 더 긴 직업에 대한 선호도가 주어진다.  |
| SRTF      | SJF와 마찬가지로 CPU 할당은 가장 낮은 CPU 버스트 시간(BT)을 기반으로 합니다. 하지만 그건 선제적이야.  | FCFS보다 더 복잡한                       | 도착 시간, 공정 크기 등 몇 가지 조치에 따라 | 네   | 네   | 짧은 직업에 대한 선호도가 주어진다.   |
| RR        | 프로세스의 순서에 따라 고정 시간 양자(TQ)로 도착합니다.                                 | 복잡성은 시간 양자 크기에 달려 있다.              | SJF와 우선순위 스케줄링에 비해 크다.     | 네   | 아니  | 각 과정은 상당히 고정된 시간을 주었다. |
| 우선 선제     | 우선순위에 따라. 더 큰 우선순위 작업이 먼저 실행됩니다.                                  | 이 유형은 덜 복잡하다.                      | FCFS보다 작은                  | 네   | 네   | 음 성능이지만 굶주림 문제가 있어     |
| 우선 순위 비선제 | 새로운 우선 순위가 높은 일자리를 모니터링하는 우선 순위에 따라                               | 이 유형은 우선 선점보다 덜 복잡하다.              | FCFS보다 작은 선제               | 아니  | 네   | 배치 시스템에 가장 유익하다.       |
| MLQ       | 더 큰 대기열 우선 순위에 있는 과정에 따르면                                         | 우선 순위 스케줄링 알고리즘보다 더 복잡하다.          | FCFS보다 작은                  | 아니  | 네   | 좋은 성과지만 굶주림 문제가 있다.    |
| MFLQ      | 더 큰 우선순위 대기열의 과정에 따라.                                             | 그것은 가장 복잡하지만 복잡성 비율은 TQ 크기에 달려 있다. | 많은 경우에 모든 스케줄링 유형보다 작다.    | 아니  | 아니  | 좋은 성능                  |
