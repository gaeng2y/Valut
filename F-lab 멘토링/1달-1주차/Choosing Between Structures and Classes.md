데이터 및 모델 동작을 저장하는 방법을 결정한다.
## Overview
구조체와 클래스는 데이터를 저장하거나 행동을 모델링할 때 좋은 선택이다. 그러나 그들의 유사성으로 인해 하나를 선택하기가 어려울 수 있다.

앱에 새 데이터 유형을 추가할 때 어떤 옵션이 적합한지 선택하려면 다음 권장 사항을 고려하세요.
- 기본적으로 구조체를 사용하라.
- Objective-C 상호 운용성이 필요한 경우 클래스를 사용하라.
- 모델링하는 데이터의 ID를 제어해야 할 경우 클래스를 사용하라.
- 프로토콜과 함께 구조체를 사용하여 구현을 공유함으로써 동작을 채택합니다.
## Choose Structures by Default
구조체를 사용하여 일반적인 종류의 데이터를 나타냅니다. Swift의 구조체에서는 다른 언어의 클래스로 제한되는 많은 기능이 포함되어 있습니다. 여기에는 저장 속성, 계산 속성 및 메서드가 포함될 수 있습니다. 또한 Swift 구조체는 기본 구현을 통해 동작을 얻기 위해 프로토콜을 채택할 수 있습니다. Swift 표준 라이브러리 및 Foundation은 숫자, 문자열, 배열 및 딕셔너리와 같이 자주 사용하는 유형에 대한 구조체를 사용합니다. 

구조체를 사용하면 앱의 전체 상태를 고려할 필요 없이 코드의 일부를 더 쉽게 추론할 수 있습니다. 구조체는 클래스와 달리 값 유형이기 때문에 구조에 대한 로컬 변경 사항은 앱 흐름의 일부로 해당 변경 사항을 의도적으로 전달하지 않는 한 앱의 나머지 부분에 표시되지 않습니다. 결과적으로, 코드 섹션을 보고 접선적으로 관련된 함수 호출에서 눈에 보이지 않게 변경되는 것이 아니라 해당 섹션의 인스턴스에 대한 변경이 명시적으로 이루어지리라는 것을 더 확신할 수 있습니다.

### Use Classes When You Need Objective-C Interoperability
데이터를 처리해야 하는 Objective-C API를 사용하거나 데이터 모델을 Objective-C 프레임워크에 정의된 기존 클래스 계층 구조에 맞춰야 하는 경우 클래스 및 클래스 상속을 사용하여 데이터를 모델링해야 할 수도 있습니다. 예를 들어 많은 Objective-C 프레임워크는 하위 클래스로 예상되는 클래스를 노출합니다.

### Use Classes When You Need to Control Identity

Swift의 클래스는 참조 유형이기 때문에 identify 개념이 내장되어 있습니다. 이는 두 개의 다른 클래스 인스턴스가 각 저장 속성에 대해 동일한 값을 가질 때 항등 연산자( === )에 의해 여전히 다른 것으로 간주된다는 것을 의미합니다. 이는 또한 앱 전체에서 클래스 인스턴스를 공유할 때 해당 인스턴스에 대한 변경 사항이 해당 인스턴스에 대한 참조를 보유하는 코드의 모든 부분에 표시된다는 것을 의미합니다. 이러한 종류의 ID를 갖기 위해 인스턴스가 필요한 경우 클래스를 사용하십시오. 일반적인 사용 사례는 파일 핸들, 네트워크 연결 및 `CBCentralManager`와 같은 공유 하드웨어 중개자입니다. 

예를 들어 로컬 데이터베이스 연결을 나타내는 유형이 있는 경우 해당 데이터베이스에 대한 액세스를 관리하는 코드는 앱에서 볼 수 있는 데이터베이스 상태를 완전히 제어해야 합니다. 이 경우 클래스를 사용하는 것이 적절하지만, 공유 데이터베이스 개체에 액세스할 수 있는 앱 부분을 제한해야 합니다.

> [!warning]
> 신원을 주의 깊게 다루십시오. 앱 전체에서 클래스 인스턴스를 광범위하게 공유하면 논리 오류가 발생할 가능성이 높아집니다. 많이 공유되는 인스턴스를 변경하면 어떤 결과가 나올지 예상하지 못할 수도 있으므로 이러한 코드를 올바르게 작성하는 것이 더 많은 작업입니다.

### Use Structres When You Don't Control Identify

제어할 수 없는 ID를 가진 엔터티에 대한 정보가 포함된 데이터를 모델링할 때 구조를 사용합니다.

예를 들어, 원격 데이터베이스를 참조하는 앱에서 인스턴스의 ID는 외부 엔터티가 완전히 소유하고 식별자를 통해 전달될 수 있습니다. 앱 모델의 일관성이 서버에 저장되어 있는 경우 레코드를 식별자가 있는 구조체로 모델링할 수 있습니다. 아래 예에서 jsonResponse에는 서버의 인코딩된 PenPalRecord 인스턴스가 포함되어 있습니다.

```swift
struct PenPalRecord {
    let myID: Int
    var myNickname: String
    var recommendedPenPalID: Int
}


var myRecord = try JSONDecoder().decode(PenPalRecord.self, from: jsonResponse)
```

`PenPalRecord`와 같은 모델 유형에 대한 로컬 변경이 유용합니다. 예를 들어 앱은 사용자 피드백에 대한 응답으로 여러 다른 펜팔을 추천할 수 있습니다. `PenPalRecord` 구조체는 기본 데이터베이스 레코드의 ID를 제어하지 않기 때문에 로컬 `PenPalRecord` 인스턴스에 대한 변경 사항이 실수로 데이터베이스의 값을 변경할 위험이 없습니다. 앱의 다른 부분에서 `myNickname`을 변경하고 서버에 변경 요청을 다시 제출하는 경우 가장 최근에 거부된 펜팔 추천이 변경 사항으로 인해 실수로 선택되지 않습니다. `myID` 속성은 상수로 선언되므로 로컬에서 변경할 수 없습니다. 결과적으로 데이터베이스에 대한 요청으로 인해 실수로 잘못된 레코드가 변경되지 않습니다.

### Use Structures and Protocols to Model Inheritance and Share Behavior

구조체와 클래스는 모두 상속 형식을 지원합니다. 구조체와 프로토콜은 프로토콜만 채택할 수 있습니다. 클래스에서 상속할 수 없습니다. 그러나 클래스 상속으로 구축할 수 있는 상속 계층의 종류는 프로토콜 상속 및 구조를 사용하여 모델링할 수도 있습니다. 

상속 관계를 처음부터 구축하는 경우 프로토콜 상속을 선호하세요. 프로토콜은 클래스, 구조체 및 열거형이 상속에 참여할 수 있도록 허용하는 반면, 클래스 상속은 다른 클래스하고만 호환됩니다. 데이터 모델링 방법을 선택할 때 먼저 프로토콜 상속을 사용하여 데이터 유형의 계층 구조를 구축한 다음 해당 프로토콜을 구조에 채택하십시오.

### Reference
https://developer.apple.com/documentation/swift/choosing-between-structures-and-classes

## Wrap-up
구조체와 클래스는 데이터를 저장하거나 동작을 모델링할 때 사용할 수 있는 두 가지 주요 옵션입니다. 다음 권장 사항을 고려하여 적합한 선택을 하세요:

### 기본적으로 구조체 사용

- **일반 데이터**: 일반적인 데이터 유형을 나타낼 때 구조체를 사용합니다.
- **값 유형(Value Types)**: 구조체는 값 유형으로, 변경 사항이 로컬에만 적용되어 예측 가능성이 높습니다.
- **프로토콜 채택**: 구조체는 프로토콜을 채택하여 동작을 공유할 수 있습니다.

### 클래스 사용

- **Objective-C 상호 운용성**: Objective-C API와 상호 운용이 필요할 때 클래스 사용.
- **ID 제어 필요**: 클래스는 참조 유형으로, 식별자 제어가 필요한 경우에 적합합니다. 예를 들어, 파일 핸들, 네트워크 연결 등.

### 구조체 선택 시 이점

- **로컬 변경**: 값 유형이므로 로컬 변경 사항이 다른 부분에 영향을 미치지 않습니다.
- **쉽게 추론 가능**: 변경 사항이 명시적으로 나타나므로 코드의 일부만 보고도 예측 가능성이 높습니다.

### 클래스 선택 시 유의점

- **참조 유형**: 인스턴스가 공유되며, 변경 사항이 참조를 보유한 모든 곳에 반영됩니다.
- **주의 필요**: 클래스 인스턴스를 광범위하게 공유하면 논리 오류 발생 가능성이 높아집니다.

### ID를 제어할 필요가 없을 때 구조체 사용

- **외부 ID**: 외부 엔터티가 ID를 소유하는 경우, 예를 들어 원격 데이터베이스 레코드를 모델링할 때 구조체를 사용합니다.
- **로컬 변경 안전성**: 구조체는 로컬 변경이 데이터베이스에 영향을 미치지 않도록 합니다.

### 구조체와 프로토콜을 사용하여 상속과 동작 공유

- **프로토콜 상속**: 프로토콜 상속을 사용하여 구조체, 클래스, 열거형 모두 상속 계층에 참여할 수 있도록 합니다.
- **구조체 채택**: 데이터 유형의 계층 구조를 구축할 때 프로토콜 상속을 선호하고, 해당 프로토콜을 구조체에 채택합니다.

ID -> 인스턴스 구분이 필요한가 안필요한가