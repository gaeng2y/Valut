Observation in Swift 구현은 강력하고 타입-안전하며 성능이 우수한 관찰자 디자인 패턴을 제공합니다. 이 패턴을 통해 관찰 가능한 객체는 관찰자 목록을 유지하고 특정 또는 일반적인 상태 변화를 알릴 수 있습니다. 이는 객체 간의 직접적인 결합 없이 여러 관찰자에 걸쳐 업데이트를 암시적으로 분산할 수 있는 장점을 제공합니다. 타입을 관찰 가능하게 선언하기 위해, 타입 선언에 Observable() 매크로를 사용합니다. 이 매크로는 컴파일 시점에서 해당 타입이 Observable 프로토콜을 준수하도록 선언하고 구현합니다. 변화를 추적하기 위해서는 withObservationTracking(_:onChange:) 함수를 사용하여, 예를 들어 차량의 이름이 변경될 때 onChange 클로저를 호출합니다.

SwiftUI 앱은 사용자가 앱의 사용자 인터페이스(UI)를 통해 변경할 수 있는 데이터를 표시할 수 있습니다. 데이터를 관리하기 위해 앱은 데이터 모델을 생성하는데, 이는 데이터를 나타내는 사용자 정의 타입입니다. 데이터 모델은 데이터와 데이터와 상호 작용하는 뷰 사이의 분리를 제공합니다. 이 분리는 모듈성을 증진시키고, 테스트 가능성을 개선하며, 앱의 작동 방식을 이해하기 쉽게 도와줍니다.

모델 데이터(즉, 데이터 모델의 인스턴스)를 화면에 표시된 내용과 동기화하는 것은 도전적일 수 있는데, 특히 데이터가 UI의 여러 뷰에 동시에 나타날 때 더욱 그렇습니다.

SwiftUI는 Observation을 통해 앱의 UI를 데이터 변경과 동기화시켜 업데이트를 도와줍니다. Observation을 사용하면 SwiftUI 뷰는 관찰 가능한 데이터 모델에 의존성을 형성하고 데이터가 변경될 때 UI를 업데이트할 수 있습니다.

모델 데이터를 관찰 가능하게 만들기 위해서는 데이터 모델에 Observable() 매크로를 적용합니다. 이 매크로는 컴파일 시간에 데이터 모델에 관찰 지원을 추가하는 코드를 생성하여 데이터 모델 코드가 데이터를 저장하는 프로퍼티에 집중할 수 있게 합니다. 예를 들어, 다음 코드는 책에 대한 데이터 모델을 정의합니다:

```swift
@Observable class Book: Identifiable {
    var title = "Sample Book Title"
    var author = Author()
    var isAvailable = true
}
```

Observable 매크로는 관찰 기능을 추가할 뿐만 아니라 데이터 모델 타입을 Observable 프로토콜에 일치시킵니다. 이 프로토콜은 다른 API에 타입이 관찰을 지원한다는 신호를 제공합니다. 데이터 모델 타입에 Observable 프로토콜만 적용하지 말고, 항상 Observable 매크로를 사용하여 타입에 관찰 지원을 추가하세요.

뷰에서 모델 데이터를 관찰하는 방법은 다음과 같습니다. SwiftUI에서 뷰는 뷰의 body 프로퍼티가 객체의 프로퍼티를 읽을 때 관찰 가능한 데이터 모델 객체에 대한 의존성을 형성합니다. body가 관찰 가능한 데이터 모델 객체의 어떤 프로퍼티도 읽지 않으면, 뷰는 의존성을 추적하지 않습니다.

트랙된 프로퍼티가 변경되면, SwiftUI는 뷰를 업데이트합니다. body가 읽지 않는 다른 프로퍼티가 변경되면 뷰는 영향을 받지 않고 불필요한 업데이트를 피합니다. 예를 들어, 다음 코드의 뷰는 책의 제목이 변경될 때만 업데이트되며, 저자나 사용 가능 여부가 변경되어도 업데이트되지 않습니다:

```swift
struct BookView: View {
    var book: Book
    
    var body: some View {
        Text(book.title)
    }
}
```

이런 방식으로 SwiftUI는 관찰 가능한 타입을 저장하지 않는 경우에도 의존성 추적을 설정합니다. 예를 들어 전역 속성이나 싱글턴을 사용할 때도 마찬가지입니다.