Ref: https://engineering.linecorp.com/ko/blog/about-swift-concurrency

앱의 성능 향상을 위해서는 알맞은 동시성 코드를 작성해야 한다. 여러 요청이 동시에 올 수 있고 그러한 요청들을 동시에 수행해야 하기 때문에 동시성 프로그래밍이 필요하다. 

## 동시성 프로그래밍
동시성 프로그래밍은 많은 수의 코어를 효율적으로 활용하는 데 도움을 준다. 해당 시점에서 사용 가능한 코어를 하나 이상 사용해서 처리 속도를 높이거나, 중요하지 않은 작업을 중요도가 낮은 스레드에서 실행시키는 이점을 얻는다.

### Dispatch
현재 iOS 개발에서 주로 사용되고 있는 동시성 프로그래밍 API이다. Swift가 나오기 전인 Objective-C부터 존재하던 개념으로, 동시성 프로그래밍에 대한 높은 수준의 추상화를 제공한다. Serial DispatchQueue는 한 번에 하나의 태스크를 순차적으로 실행하고, concurrent DispatchQueue는 많은 작업을 동시에 실행한다. 두 경우 모두 작업이 실행되는 순서는 FIFO다.

### Swift Concurrency
Swift Concurrency는 동시성 프로그래밍을 가독성이 좋은 깔끔한 코드로 작성하고자 도입된 개념이다. `async`와 `await` 키워드를 이용해 비동기 태스크 종료 후 코드를 작성할 수 있다. `await` 키워드로 인해 중지되면 이후에 사용해야 하는 데이터를 힙(heap) 영역에 저장해 두고, 이후에 다시 힙 영역에서 해당 데이터를 가져와 사용한다.

### Dispatch와 Concurrency 비교

##### 에러 핸들링
Dispatch에서는 completion Handler를 통해 error를 전달하지만 Concurrency에서는 throw를 통해 에러 핸들링을 할 수 있다.

##### 동기화 처리
동시성 프로그래밍을 할 때 중요하게 생각해야 하는 점 중 하나는 동기화(synchronization) 문제다. 동시에 실행되는 여러 코드에서 하나의 변수에 접근할 수 있기 때문에 이를 올바르게 처리해야 한다.

Dispatch에서 동기화를 안전하게 처리하는 방법은 `DispatchQueue.sync`를 통해 순서대로 접근하는 것을 보장하거나 뮤택스나 세마포어를 이용하는 방법 등이 있다. 하지만 컴파일러가 확인해주지 않아 동기화 관련 버그가 발생할 수 있다.

Concurrency에서는 이를 컴파일 단계에서 확인해 동기화를 제대로 처리하지 않은 코드가 있다면 컴파일 에러 발생.

비 독립적(non-isolated) 구문이 변할 수 있는 프로퍼티에 접근하는 것을 금지한다는 메시지와 함께 컴파일 에러가 발생합니다. 이를 통해 개발자의 실수로 데이터 레이스 문제 발생하는 것을 방지.

#### 성능

스레드 생성량과 콘텍스트 스위칭 수를 비교해 보고, Concurrency에서 우선순위 역전을 어떻게 방지하는 지 알아보자.
##### 스레드
Dispatch에서 조심해야할 점 중 하는 thread explosion이다. thread explosion이 발생하면 컨텍스트 스위칭(context switching)이 많아지고 성능이 저하될 수 있으며, 블록된 스레드가 어떤 자원을 잠그고(lock) 있을 때 데드락을 발생시킬 수도 있다.

즉, thread explosion이 발생하면 너무 많은 스레드 블록에서 유발되는 메모리 오버헤드, 너무 많은 컨텍스트 스위칭에서 유발되는 스케줄링 오버헤드가 발생할 수 있다. 이에 따라 thread explosion을 막기 위해 하나의 서브시스템에 하나의 Dispatch Queue 혹은 Dispatch Queue 위계(hierarchy)를 할당하는 것이 권장되고 있다. 이는 서로 연관된 작업이 하나의 스레드에서 실행될 수 있게 하는 의도다.

반면 Concurrency에서는 보다 편하게 관리할 수 있다. `await`으로 중단됐을 때, CPU가 컨텍스트 스위칭을 해서 다른 스레드를 불러오는 것이 아니라 같은 스레드에서 다음 함수를 실행시킨다. 즉, 하나의 코어가 하나의 스레드를 실행하도록 유지하는 것을 보장한다. 기존에 스레드의 컨텍스트 스위칭으로 진행되던 것이 같은 스레드 내의 함수 호출로 대체되는 것이다.

> [!info]
>주의할 점은, 미리 API에 구현된 `async` 함수를 사용하는 것이 아닌 새로운 `async` 함수를 구현할 때에는 중단 지점을 지정해 줘야 한다는 것이다. 이는 위 코드에서와 같이 `Task.yield()`를 통해서 스레드를 할당받거나 양보하는 지점을 정해줄 수 있다. 만약 `async`로 함수를 작성했는데 `await`을 이용한 중단 지점이 함수 내에 없다면 비동기가 아닌 동기로 동작한다.

### 우선순위 역전

Dispatch를 이용해 동시성 프로그래밍을 하다면 우선순위 역전이 발생할 수 있다. 하나의 큐에 Qos가 각기 다른 작업이 담길 수 있기 때문이다.

예를 들어 Background QoS인 태스크들이 큐에 추가된 후 User Initiated QoS인 태스크가 추가됐다고 가정해보자. 이런 경우 GCD에서는 앞에 있던 background QoS 태스크들의 우선순위를 user initiated로 높여서 새로 추가된 태스크가 너무 오래 앞선 태스크를 기다리지 않게 해준다.

반면 Concurrency에서는 좀 더 근본적인 해결책을 제공한다. Dispatch의 경우 FIFO로 태스크를 실행시키기 때문에 앞의 태스크들의 우선순위를 높이는 방식을 선택하지만, Concurrency에서는 작업이 실행되는 순서가 FIFO가 아니기 때문에 우선순위가 높은 태스크 먼저 실행시킬 수 있다.

