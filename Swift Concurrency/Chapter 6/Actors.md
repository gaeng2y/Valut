지금까지 우리는 서로 독립적인 작업을 사용하여 Swift에서 동시 코드를 작성하는 방법을 다루었습니다. 

일부 작업을 실행하고 결과를 기본 스레드에 전달하는 경우가 많습니다. 

그러나 프로그램에서 변경 가능한 상태를 공유해야 하는 경우가 있습니다. 이는 코드에서 읽고 쓸 수 있는 일반적인 변경 가능한 소스입니다. 

이 소스는 단순한 변수일 수도 있고, 파일일 수도 있고, 동시에 액세스하기 위험한 다른 종류의 리소스일 수도 있지만 동시에 여러 작업에서 사용할 수 있어야 합니다.

읽기 전용 액세스할 수 있는 코드가 여러 개 있는 경우 리소스가 없으면 프로그램은 항상 유효한 상태에 있으므로 이 경우 데이터 손상에 대해 걱정할 필요가 없습니다. 그러나 여러 작업이 있고 그 중 적어도 하나가 공유 리소스에 데이터를 쓸 수 있다면 문제가 있는 것입니다. 이것을 데이터 경쟁이라고 합니다.

1장, 경쟁 조건. 경쟁 조건은 위험합니다. 여러 코드 조각이 파일에 동시에 쓸 수 있으면 데이터가 손상될 수 있기 때문입니다.

여러 작업이 해당 리소스에서 읽는 경우 모든 작업이 읽으려고 시도한 것과 동일하지 않을 수도 있는 쓰레기 데이터가 있습니다.

최악의 부분은 낮은 수준에서 동시 코드를 작성하는 경우 데이터 경합을 도입하는 것은 매우 쉽고 디버그하기는 매우 어렵습니다.

이러한 이유로 값 의미 체계(구조체 또는 열거형)를 사용하는 경우 이 문제는 발생하지 않습니다. 값 의미 체계는 읽기 전용이며, 변경되면 복사본이 생성되고 모든 변경은 해당 변수에 국한됩니다. 

각 작업은 원하는 것이 아닐 수도 있지만 서로 다른 데이터 복사본에서 작동합니다.

Chapter 1에서 우리는 이 문제에 대한 낮은 수준의 해결책이 locks를 사용하여 자원에 대한 액세스를 수동으로 동기화하는 것임을 보았다.

하지만 새로운 스위프트 동시성 모델에서, 우리는 그러한 동기화를 만드는 훨씬 더 쉬운 방법이 있다: Actors. 