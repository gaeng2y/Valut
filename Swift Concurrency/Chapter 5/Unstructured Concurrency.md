구조화되지 않은 동시성은 약간 적은 유용성에 대한 대가로 더 많은 유연성을 제공한다. 구조화되지 않은 동시성으로 작업할 때, 당신의 코드는 반드시 우리가 사랑하게 된 위에서 아래로 구조를 따르지는 않을 것입니다.

### 깊이있는 Task
Task는 우리가 두 가지 중요한 일을 할 수 있게 해주는 유용한 물건이다.
1. 이니셜라이저로 작업이 생성되는 순간, 폐쇄 내에서 코드를 비동기적으로 시작합니다.
2. 그것은 우리가 비동기 메소드를 호출하는 방식으로 동시성을 사용할 수 있는 동시 컨텍스트를 만듭니다.

**Task**는 객체이므로, 변수에 저장할 수 있습니다. 이것이 "구조화되지 않은 동시성"이라고 불리는 이유의 일부가 오는 곳이다.

여러 Task 객체를 가질 수 있고, 변수에 저장하거나, 심지어 컬렉션에 저장할 수도 있습니다. 그리고 구조화된 동시성으로 할 수 없는 구조화되지 않은 동시성으로 할 수 있는 한 가지는 작업을 취소하는 것입니다.

우리는 Task<Bool, Error> 유형의 변수를 만들었습니다. 이것은 context.evaluatePolicy(_:localizedReason:)가 Bool을 반환하고 오류를 던질 수 있기 때문입니다.

우리의 Task가 값을 반환하고 오류를 던질 수 있기 때문에 우리는 try await를 사용해야 한다.
