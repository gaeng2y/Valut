우리는 이 새로운 도구가 절차적 프로그래밍과 유사한 구조화된 코드를 작성하는 데 어떻게 도움이 될 수 있는지 보았습니다. 왜냐하면 우리는 클로저 및 대리자와 같은 코드의 선형 가독성을 깨는 다른 유형의 콜백을 제거할 수 있기 때문입니다.
## Structured Concurrency 이해하기
Structured Concurrency는 구조적 프로그래밍과 같은 아이디러르 따른다.
그것은 우리가 예상하는 순서대로 코드를 작성하고 예측 가능한(또는 적어도 반 예측 가능한) 결과를 보는 것에 관한 것이다.

클로저 기반 코드와 달리, 변수는 잘 정의된 범위를 가지고 있으며, 코드가 코드의 읽기 흐름을 깨뜨리는 다른 장소로 이동하지 않을 것으로 기대할 수 있습니다.

이것은 또한 메모리 관리와 같은 다른 세부 사항에 대해 걱정할 수 있습니다 (블록에 캡처된 변수는 어떻게 되나요? 폐쇄를 유지할 수 있나요? "weak self"? 응?). 

그리고 그것은 당신이 동시적이지 않은 클로저 기반 호출에 대해서만 생각하고 있다면입니다. 많은 독립 코드가 동시에 실행되는 여러 개의 클로저 기반 동시 호출이 있는 코드를 상상할 수 있나요?

구조화된 동시성을 사용하면 여러 클로저 기반 호출을 통해 점프하는 코드의 미로에 대해 생각할 필요 없이 예측할 수 있는 결과로 여러 코드 경로를 동시에 실행할 수 있습니다.

새로운 asycn/await 시스템은 구조화된 동시성을 수행하는 두 가지 방법을 제공합니다: async let 구성과 Task 그룹. 

## async let 구성
async let 바인딩으로도 알려져 있다. 