# Multithreading Pitfulls

### 교착 상태

멀티스레딩의 맥락에서, 두 개의 다른 프로세스가 완료되기를 기다리고 있을 때 교착 상태가 발생하며, 효과적으로 그들 중 어느 것도 끝내는 것을 불가능하게 만든다.

이것은 두 프로세스가 자원을 공유할 때 발생할 수 있다.

![[Pasted image 20231002190737.png]]
### 교착 상태 해결 방법

교착 상태 문제에는 많은 확립된 해결책이 있다. Mutex와 Semaphores가 가장 많이 사용된다.

### 뮤텍스

Mutex는 상호 배타적인 자물쇠(또는 깃발)의 줄임말이다.

뮤텍스는 잠금을 추가하고 잠금이 해제될 때까지 다른 프로세스가 잡히지 않도록 함으로써 프로세스가 현재 일부 리소스를 사용하고 있다는 것을 다른 프로세스에 알릴 것이다.

이렇게 하면, 스레드 A가 리소스 C와 리소스 D가 필요한 경우, 스레드 B가 액세스하려고 시도하기 전에 잠글 수 있습니다.

![[Pasted image 20231002190800.png]]

뮤텍스를 이용하는 상황에서, 스레드 A와 스레드 B는 멀티스레드가 있지만 동시에 엄격하게 실행되지 않는다는 것을 의미합니다.

이러한 이유로, 멀티스레드 시스템을 설계하기 전에 병렬로 실행할 수 있는 작업을 식별하는 것이 중요합니다.

### 세마포

세마포는 뮤텍스와 비슷한 자물쇠의 일종이다. 이 해결책으로, 작업은 자원에 대한 잠금을 획득할 것이다.

Mutex와 Semaphores는 비슷하게 들리지만, 주요 차이점은 그들이 어떤 종류의 자원을 잠그고 있는지에 있으며, 무엇을 보호해야 할지 결정해야 하는 상황에서 자신을 발견한다면(비동기/대기를 사용할 때 그러한 경우를 찾을 수 없을 것입니다), 사용 사례에서 무엇이 의미가 있는지 생각하는 것이 중요합니다.

일반적으로, 뮤텍스는 파일, 소켓 및 기타 파일 시스템 요소와 같이 자체적으로 실행되지 않는 모든 것을 보호하는 데 사용될 수 있습니다.

세마포어는 프로그램 자체의 실행을 보호하는 데 사용될 수 있으며, 이는 코드 실행 경로를 공유합니다.

이것들은 공유 상태를 가진 함수나 클래스를 변형시킬 수 있다. 하나 이상의 스레드로 함수를 실행하면 의도하지 않은 결과가 발생할 수 있으며, 세마포는 이를 위한 좋은 도구입니다.

# **Starvation**

기아 문제는 프로그램이 자원이 어떤 일을 하기를 끊임없이 기다리고 있지만 결코 받지 못하는 상태에 갇혀 있을 때 발생한다.

기아 문제의 대표적인 표현으로는 [식사하는 철학자 문제](https://namu.wiki/w/%EC%8B%9D%EC%82%AC%ED%95%98%EB%8A%94%20%EC%B2%A0%ED%95%99%EC%9E%90%20%EB%AC%B8%EC%A0%9C)가 있습니다.

그 문제는 공유 테이블에서 먹고 싶어하는 다섯 명의 철학자를 보여준다. 그들 모두는 그들만의 접시를 가지고 있고, 다섯 개의 포크가 있다. 하지만, 각 철학자는 먹기 위해 두 개의 포크가 필요하다.

포크는 5개밖에 없기 때문에 한번에 두 철학자 밖에 먹을 수 없는 상황에 먹고있는 철학자가 과식을 하게 된다면 다른 철학자는 굶을 수 밖에 없습니다.

운 좋게도 낮은 수준의 멀티스레딩 개발자에게는 이 문제를 해결하기 위해 위에서 이야기한 세마포어를 사용할 수 있습니다.

# Race Conditions(경쟁 조건)

대부분의 개발자들이 익숙한 멀티스레딩 문제일 가능성이 있으며, 경쟁 조건은 다른 불쾌한 결과를 초래할 수 있는 데이터 또는 메모리 손상을 일으킬 수 있다는 점을 제외하고는 교착 상태와 매우 유사합니다.

멀티스레딩을 다룰 때, 두 프로세스가 동시에 데이터를 읽는 것은 본질적으로 나쁜 것이 아니다.

자원이 읽기 전용이라면 해가 없다. 그러나, 프로세스가 어떤 식으로든 자원을 수정하거나 업데이트할 수 있다면, 프로세스는 다른 프로세스가 방금 작성한 데이터를 지속적으로 덮어쓸 것이며, 이는 결국 손상된 데이터를 읽고 쓰는 것으로 이어질 것이다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/5d29900c-d112-4c82-ba00-32aa606edd72/da1c8c27-2a5f-4042-8bda-6ca16c58546e/Untitled.png)

교착 상태와 경주 조건은 매우 비슷하다. 교착 상태의 주요 차이점은 다른 프로세스가 완료되기를 기다리는 여러 프로세스가 있는 반면, 경쟁 조건에서는 문제의 자원이 다른 사람이 사용하고 있다는 것을 알지 않기 때문에 데이터를 작성하고 손상시키는 프로세스가 모두 있다는 것입니다.

이것은 교착 상태에 대한 해결책이 경쟁 조건에도 적용된다는 것을 의미하므로, 하나의 프로세스로만 자원에 대한 독점적인 접근을 보장하기 위해 뮤텍스 또는 세마포어로 자원을 차단하십시오. 이것은 원자 작전이라고 불린다.

# Livelocks

라이브락은 두 스레드가 락의 헤제와 획득을 무한 반복하는 상태이다.

라이브락은 데드락을 피하려는 의도에서 수정한 코드가 불완전할 때 발생하곤 한다.

# 기존 멀티스레딩 및 동시성 도구

### pthreads

pthreads(POSIX Threads)는 IEEE.1에 의해 정의된 표준의 구현입니다. 이름(휴대용 운영 체제 인터페이스)의 POSIX 부분(휴대용 운영 체제 인터페이스)은 Apple의 운영 체제뿐만 아니라 많은 플랫폼에서 사용할 수 있음을 알려줍니다.

### NSThreads

NSThread는 Apple에서 제공하는 재단 객체이다. 그것들은 낮은 수준이지만, pthreads만큼 낮은 수준은 아니다. 그것들은 기초 객체이기 때문에, Objective-C 인터페이스를 제공한다.

### Dispatch(구 GCD)

우리는 이제 Apple 플랫폼에서 높은 수준의 동시성 및 멀티스레딩을 위한 최초의 고급 도구에 대해 이야기할 것입니다. 그랜드 센트럴 디스패치(여기서부터 간단히 GCD라고 함)는 애플의 SDK 전반에 걸쳐 유비쿼터스이기 때문에 모르는 사이에도 사용했을 가능성이 높습니다.

높은 수준의 GCD는 pthreads와 NSThreads보다 많은 일을 하지 않도록 해준다. GCD를 사용하면 수동으로 스레드를 관리하는 데 전혀 신경을 들이지 않을 것입니다. 그것은 진정으로 그런 의미에서 높은 수준의 프레임워크이지만, 자체 수하물도 운반한다. 일부 개발자들이 GCD로 작업할 때 가지고 있는 고전적인 문제를 보여준다.

```swift
func fetchUser() {
    userApi.fetchUserData { userData in
        DispatchQueue.main.async {
            self.usernameLabel.text = userData.username
            self.userApi.fetchFavoriteMovies(for: userData.id) { movies in
				DispatchQueue.main.async {
                    self.userMovies = movies
                } 
            }
		} 
	}
}
```

위 코드는 Dispatch를 이용한 매우 전형적인 코드이다. 사용자의 데이터와 그들이 가장 좋아하는 영화를 어딘가에서 검색한다.
### NSOperation APIs

GCD보다 더 높은 수준에 위치한 NSOperation API는 멀티스레딩을 수행하는 높은 수준의 도구입니다. 그들이 GCD만큼 널리 알려져 있지 않다는 사실에도 불구하고, 그들은 SDK의 일부에서 그들의 자리를 찾았다.

이것은 당신을 위해 멀티스레딩의 많은 고통을 진정으로 추상화하지만, 많은 유연성을 잃습니다.

# async/await 소개
Async/await는 동시 및 다중 스레드 코드를 작성하는 고급 시스템입니다.
그것을 사용하면 수동 스레드 관리나 교착 상태에 대해 생각할 필요가 없습니다.

의미론적으로, async/await은 언어 자체인 스위프트에 깊이 통합되어 있기 때문에 우리가 이전에 탐구한 다른 시스템과 async/await을 비교하기는 어렵다. 그것은 프레임워크나 라이브러리 형태의 애드온이 아니다.

```swift
@MainActor
func fetchUser() async {

    let userData = await userApi.fetchUserData()
    usernameLabel.text = userData.username
    let movies = userApi.fetchMovies(for: userData.id)
    userMovies = movies

}
```
위 코드는 GCD에서 사용한 코드를 async/await를 하용하는 걸로 바꾼 것이다.

@MainActor는 유명한 Actor로 알려져 있다. 우리는 책의 뒷부분에서 배우와 글로벌 배우를 탐구할 것이다. 현재로서는, @MainActor가 표시된 함수 또는 클래스 내의 멤버 업데이트가 메인 스레드에서 실행되도록 할 것이라는 것을 알아두세요.

# 요약

동시성과 멀티스레딩은 전통적인 컴퓨팅 문제이다. 
낮은 수준에서 동시성을 수행하고 자원을 직접 관리하는 것은 오용하기 쉽기 때문에 어려울 수 있다. 
이러한 리소스를 오용하고 멀티스레드 코드를 올바르게 얻지 않으면 최상의 경우 버그가 발생하고 최악의 경우 사용자 데이터가 손상됩니다. 

이 때문에, 애플을 포함한 많은 개발자들은 세부 사항을 추상화하고 더 쉬운 인터페이스를 제공하기 위해 여러 도구를 설계했다. 
Apple의 경우, 그들은 개발자에게 다음과 같은 도구를 제공했습니다(낮은 수준에서 더 높은 수준으로 정렬됨): 
* pthreads 
* NSThreads 
* Grand Central Dispatch (GCD) 
* NSOperation 및 관련 API 
* async/await 
대부분의 개발자는 pthread 또는 NSThread 수준으로 내려갈 필요가 없습니다. 
GCD와 NSOperation API는 더 높은 수준의 추상화를 제공하는 반면, "async/await"는 멀티스레딩 프리미티브에 대한 추상화를 제공할 뿐만 아니라 대부분의 개발자가 아래의 구성 요소가 무엇인지 모른 채 사용할 수 있는 전체 시스템을 제공할 것이다. 
이 새로운 시스템은 우리가 읽기 쉽고 쓰기 쉬운 짧은 코드를 작성할 수 있게 해준다. 이 새로운 시스템을 자세히 연구할 가치가 있으며, 그것이 이 책의 내용이다.

## 간단한 문제

1. When using traditional concurrency tools, what are some pitfalls you can fall into if you don’t use them correctly?
   전통적인 동시성 도구를 사용할 때 올바르게 사용하지 않으면 어떤 함정에 빠질 수 있습니까?
   GCD를 
    
2. prior to async/await, what were some concurrency tools available on apple’s platforms?
   async/await 이전에는 Apple 플랫폼에서 사용할 수 있는 동시성 도구에는 어떤 것이 있었습니까?
    
3. What advantages does async/await have over other, lower-level concurrency tools?
   async/await는 다른 하위 수준 동시성 도구에 비해 어떤 이점이 있습니까?