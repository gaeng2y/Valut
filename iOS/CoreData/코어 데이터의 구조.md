### 코어 데이터의 내부 구조
![구조](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2FdMSpfx%2FbtqD7HVLyIk%2FAAAAAAAAAAAAAAAAAAAAAGCpAzJlisawT3utIDyqK9rKmpZK4qZ02U5DYLvsD6T_%2Fimg.png%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1756652399%26allow_ip%3D%26allow_referer%3D%26signature%3DJDHGGr3y21jN%252BcbC9b18qhG4ycc%253D)
### 관리 객체(Managed Obejct) : NSManagedObject
table에서 레코드를 읽을 때 core data에서는 객체가 생성되는데, 이 객체를 저장하는 자료형

예) 직원들의 데이터를 다룰 때 DB에서 직원들의 정보를 읽어오면 이것을 그대로 사용하지 않고 VO인스턴스에 담아 사용, 이때 VO가 관리 객체에 해당
### 관리 객체 컨텍스트(Managed Object Context)

 핵심적인 두 가지 역할

 (1) MO를 가지고 CRUD역할 (Core Data에서 생성되는 모든 관리 객체는 컨텍스트에 담겨 관리)
 - 컨텍스트에 담긴 객체는 영구 저장소로 보내 저장, 삭제 가능
 - core data는 메모리에 로드된 상태로 처리되는데, 이 때의 메모리가 "컨텍스트"를 의미

 (2) "영구 저장소"와 "영구 저장소 코디네이터"에 대한 관리자 역할
 - 읽기와 쓰기를 영구 저장소에 요청 (DAO패턴과 유사)
### 영구 저장소 코디네이터(Persistent Store Coordinator)

 컨텍스트와 직접 데이터를 주고 받으면서 다양한 영구 저장소들의 접근을 조정하고 입출력을 담당

 흐름 : 컨텍스트가 데이터 요청 -> 코디네이터가 요청을 받고, 영구 저장소에서 데이터 탐색 -> 코디 네이터가 MO인스턴스 생성하여 반환
### 관리 객체 모델(Managed Obejct Model)

엔터티(Entity)의 구조를 정의하는 객체인 동시에 이를 바탕으로 MO패턴의 모델 클래스를 참조

※ MO vs MOM(Managed Object Model)
 - MOM : 클래스이자 형식이고 구조를 의미
     - 데이터를 CRUD하지 않으며 관리 객체의 각 요소를 제대로 담을 수 있도록 저장 데이터를 구조화
 - MO : MOM을 바탕으로 생성된 인스턴스
### 영구 객체 저장소(Persistent Obejct Store)
- 초기에는 직접 읽을 수 있으며 디버깅에 용이한 XML저장소 타입을 사용하며,
- 앱을 배포할 당시 대량의 데이터를 고려하여 SQLite데이터베이스를 사용하는 것이 용이

| 타입                                    | 설명                                                       |
| ------------------------------------- | -------------------------------------------------------- |
| 인메모리 저장소 타입<br>(NSInmemoryStoreType)  | 메모리 기반의 저장 방식(영구 저장소를 사용하지 않는 것)<br>앱 종료시 데이터 보존이 되지 않음  |
| 플랫 바이너리 저장소 타입<br>(NSBinaryStoreType) | 데이터를 단순 바이너리 파일 형식으로 저장<br>장점은 조회 성능 개선, 단점은 초기 로딩 시간 증가 |
| XML 저장소 타입<br>(NSXMLStoreType)        | 원자성<br>장점은 직접 열어보고 확인 가능(초기 디버깅용이), 단점은 처리 속도가 느림        |
| SQLite 데이터베이스<br>(NSSQLiteStoreType)  | 객체 그래프 중 일부만 로딩<br>가장 많이 사용                              |
### 인메모리 DB
CRUD에 대한 모든 작업은 메모리에 로딩된 데이터를 대상으로 이루어진다.

변경 내역을 영구 저장소에 반영하는 과정을 가리켜 **커밋** 또는 **동기화**라고 부르는데, 키밋이 발생하기 전까지 변경된 데이터는 메모리에서만 존재한다.

이 방식의 장점으로는 빠른 처리 속도와 성능의 향상을 꼽을 수 있다.
##### 데이터의 교환 및 저장 메커니즘
영구 저장소와 메모리에 저장된 레코드 사이에 일어나는 데이터 교환 방식은 미러링과 유사하다.

영구 저장소에서 레코드를 로딩할 때에는 저장된 레코드를 그대로 읽어 관리 객체로 만들어 내고, 반대로 관리 영구를 영구 저장소에 저장할 때에는 메모리상에서 수정된 객체가 그대로 영구 저장소에 반영되는 식이다.

영구 저장소로 SQLite를 선택한 상태에서 컨텍스트의 관리 객체를 저장소에 커밋할 때에는 **차등 저장 메커니즘**이 사용된다. (이것은 매번 데이터 전체를 커밋하는 대신 마지막 저장 이후에 변경된 부분만 커밋하는 방식으로, 빠르고 가볍게 처리할 수 있다는 장점이 있다.)

## 코어 데이터의 한계
1) in-memory방식 : 메모리에 로딩된 객체에 대해서만 수정 가능(SQLite는 메모리에 객체 모두를 로딩하지 않아도, 최소한의 데이터만 로드)
   in-memory에서 데이터 삭제시, 영구저장소에서 데이터 read -> 객체로 생성 -> 이것을 메모리에 로딩 -> 이를 삭제하고 다시 컨텍스트를 저장소에 커밋
2) 데이터 로직에서의 한계
- 중복된 값의 입력을 방지하는 "Unique"키가 없으므로, 애플리케이션에서 비즈니스 로직을 통해 처리해야 가능
3) thread-safe하지 않음(싱글스레드 환경)
   thread끼리 Lock기능(다른 쓰레드가 침범하지 못하는 것)이 존재하지 않음(단 락을 걸지 않음으로써 빠르게 데이터 처리가 가능)
- SQLite역시 싱글 스레드만 지원