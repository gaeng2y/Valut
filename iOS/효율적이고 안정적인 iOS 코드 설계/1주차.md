# 함수형 프로그래밍
**람다대수**(lambda calculus)
람다 대수란 계산을 함수와 함수의 연산으로 추상화한 체계이다. 다른 계산 모델인 튜링 기계와는 동치이며, 모든 기계적인 계산은 람다 대수로 표현할 수 있다고 믿어진다. 미국의 수학자이자 컴퓨터 과학자 알론조 처치(Alonzo Church)가 1930년대에 수학 기초론을 연구하며 고안했다.

#### 함수형 프로그래밍 대두
- 동시성 제어에 대한 이슈 제고
- 정적인 코드 작성이 쉬운 함수형 프로그래밍 대두
- 반응형 개념과 함께 선언형 아키텍처 인기
- 함수형 프로그래밍에는 **상태가 없다**.
- 파이프라인을 시작하면 멈출 수 없다.
### 일급 객체
- 대입: 상수/변수로 할당 가능
- 매개변수: 다른 함수의 내부에서 이용할 수 있도록 전달 가능
- 반환: 함수에서 결과 값으로 외부 전달 가능
이 되는 객체

근데 Swift에서 함수는 일급 객체
### 고차 함수
- 함수를 인자로 받거나 반환
**일급 함수를 지원하는 언어에서만 사용 가능한게 고차 함수**

---
## 사족
#### 엔트로피 컬리전에 대해...
"엔트로피 컬리전이 일어나면 버킷을 쌓는다"라는 표현을 분석해 보면,
1. "엔트로피 컬리전"
   "엔트로피"라는 단어는 보통 무작위성(randomness) 또는 정보량을 의미한다. 
   "컬리전(collision)"은 해시 테이블 등에서 서로 다른 입력값이 같은 해시 값을 가질 때 발생하는 충돌을 의미한다. 
   Swift에서는 Dictionary나 Set이 내부적으로 해시 테이블을 사용하므로, 해시 충돌이 발생할 가능성이 있다.
2. "버킷을 쌓는다"
   해시 테이블에서 충돌이 발생하면, 이를 해결하기 위한 방법 중 하나가 체이닝(Chaining) 방식이다.
   체이닝 방식에서는 같은 해시 값을 가진 요소들을 **버킷(bucket)** 이라는 연결 리스트 형태로 저장한다.
   즉, 충돌이 많아질수록 하나의 버킷에 여러 개의 값이 쌓이는 구조가 된다.

**추론**
"엔트로피 컬리전이 일어나면 버킷을 쌓는다"는 말은 Swift의 Dictionary나 Set에서 해시 충돌이 발생하면, 같은 해시 값을 가진 요소들이 같은 버킷에 저장되면서 성능이 저하될 수 있다는 의미로 해석할 수 있다.

**추가 설명**
Swift에서 Dictionary는 해시 테이블을 기반으로 하며, 충돌이 발생할 경우 체이닝(Chaining) 방식을 사용하여 같은 해시 값을 가진 요소들을 배열(Array) 형태의 버킷에 저장한다.
즉, 해시 값이 충돌하면 그 해시 슬롯에 연결된 버킷(리스트) 내부에서 요소를 선형 탐색해야 하므로, 컬리전이 많아질수록 검색 성능이 O(1)에서 O(n)으로 떨어질 수 있다.
#### 콜리전에 대해...
Swift든 다른 언어든, 해시(hash) 기반의 자료구조에서 “콜리전(collision)”은 아주 중요한 개념이에요. 간단히 설명드릴게요.

🔹 해시란? 해시는 어떤 데이터를 일정한 규칙에 따라 고정된 길이의 숫자(보통 정수)로 변환하는 것. 예를 들어, "apple"이라는 문자열을 18392 같은 숫자로 바꿔주는 역할이에요. 이 숫자를 이용해 배열 인덱스 같은 곳에 데이터를 빠르게 저장하거나 찾을 수 있어요.

🔹 그런데 왜 “콜리전”이 발생할까? 해시 함수는 무한한 입력(예: 문자열, 객체 등)을 제한된 숫자(예: 0~9999 등)로 변환하니까, 서로 다른 입력이 같은 해시값을 가지는 경우가 생겨요. 이걸 “해시 충돌”, 즉 “collision”이라고 해요.

예시
- "apple" → 해시값: 18392
- "banana" → 해시값: 18392 ← 다른 값인데 같은 해시!
이런 일이 생기면, 두 개의 데이터를 같은 위치에 저장할 수 없어서 뭔가 다른 처리가 필요해요.

🔹 충돌을 해결하는 방법 (버킷을 쌓는다?)
**체이닝(Chaining) 방식**
해시 테이블의 각 인덱스를 리스트(버킷)처럼 써서, 같은 해시값을 가진 여러 요소를 그 안에 쌓아둬요. 이게 아마 "버킷을 쌓는다"는 표현일 거예요.
예: 해시값 18392 → [apple, banana, peach]

**오픈 어드레싱(Open Addressing)**
충돌이 나면, 빈 공간을 찾아서 그 자리에 저장해요. (이건 Swift에서는 잘 안 쓰는 방식이에요.)

🔹 Swift에서는? Swift의 Dictionary는 체이닝 방식처럼 내부적으로 충돌된 키들을 "버킷"에 모아서 저장해요. 그래서 해시 충돌이 자주 일어나면 한 버킷에 값이 많아지고, 탐색 속도가 느려져요.

**📌 결론**
"엔트로피 컬리전이 일어나면 버킷을 쌓는다"는 말은, 무작위성이 떨어져서 해시 충돌이 자주 발생하면, Dictionary 내부의 버킷에 요소가 계속 누적되고, 이는 성능 저하로 이어질 수 있다는 뜻이에요.
#### Swift에서 Dictionary와 Set 비교
Swift 오픈소스 깃허브의 Dictionary.swift와 Set.swift는 Swift에서 Dictionary와 Set이 어떻게 구현되어 있는지 보여주는 핵심 소스입니다. 이걸 기반으로 “콜리전”과 “버킷”에 대해 조금 더 정확하고 깊이 있는 설명을 드릴게요.

**요약 포인트:**
- Swift의 Dictionary와 Set은 HashTable 기반으로 구현
- 해시 충돌(Collision)이 발생하면 동일한 “버킷(Bucket)”에 여러 요소가 들어감
- 내부적으로는 NativeDictionary, HashTable, Bucket 등으로 나뉘어 관리됨

##### 🔹 1. Dictionary와 Set은 Hashable 키를 바탕으로 hash(into:) → hashValue를 계산해 저장 위치를 결정해요.
**예시 코드 (Dictionary.swift 내부 중 일부):**
```swift
internal struct _NativeDictionary<Key: Hashable, Value> { ... internal var _hashTable: _HashTable }
```
_hashTable은 내부적으로 버킷 배열을 관리하고 있어요.

##### 🔹 2. 버킷(Bucket)이란?
**Swift 구현 내부에 보면 이런 표현이 있어요:**
```swift
struct _HashTable { ... @usableFromInline internal var buckets: UnsafeMutablePointer<_Bucket> }
```
이 buckets 배열의 각 요소가 하나의 버킷입니다. 각 버킷에는 키/값이 들어가거나, 충돌이 발생하면 다음 후보 버킷을 찾는 로직이 동작해요.

Swift는 Open Addressing 방식(구체적으로는 Linear Probing + Robin Hood Hashing)을 사용합니다.

즉, 충돌이 나면 그 다음 버킷을 탐색해서 빈 공간을 찾아 넣어요. 그래서 '버킷에 쌓는다'는 말은 실제로는 연결 리스트처럼 쌓는 체이닝 방식이 아니라, 메모리상 버킷을 연속적으로 사용하며 '덮어 쓰기 후보'를 찾는 거예요.

##### 🔹 3. Robin Hood Hashing 방식이란?
**Dictionary.swift에 다음 주석이 있어요:**
/// Insertion uses Robin Hood hashing to minimize probe length variance.
Robin Hood Hashing은 새로 들어오는 값이 기존 값보다 “더 멀리 떨어졌다면” 자리를 바꾸는 방식이에요. 이 방식은 해시 충돌이 있어도 탐색 시간을 예측 가능하게 유지해주는 장점이 있습니다.

##### 🔹 요약하면:
- Swift의 Dictionary/Set은 내부적으로 hashValue 기반으로 버킷 인덱스를 계산
- 충돌이 발생하면 open addressing 방식으로 다음 버킷을 순차 탐색 (≠ 체이닝)
- Robin Hood Hashing을 사용해 충돌 상황에서도 성능을 최대한 일정하게 유지
- “버킷을 쌓는다”는 표현은 비유적으로는 맞지만, 실제로는 연결 리스트를 쌓는 게 아니라, “다음 버킷을 점유하며 이동하는 구조”에 가깝습니다

원문 확인해보고 싶은 함수:
- `_find() (Dictionary.swift)`
- `_bucket(at:) (HashTable.swift)`
- `_insertNew() (Dictionary/Set 삽입 처리)`

