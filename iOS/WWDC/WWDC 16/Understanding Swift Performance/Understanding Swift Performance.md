Session: https://developer.apple.com/videos/play/wwdc2016/416/
Slide: https://devstreaming-cdn.apple.com/videos/wwdc/2016/416k7f0xkmz28rvlvwb/416/416_understanding_swift_performance.pdf
Ref: https://zeddios.tistory.com/596#recentComments
## Dimensions of Performance
![](Pasted%20image%2020240423001321.png)

### Allocation
Swift는 자동으로 메모리를 할당하고, 해제하는데 메모리 중 일부는 Stack에 할당된다.

다들 아시다시피, Stack은 LIFO구조로 매우 단순한 데이터 구조다.

Stack의 마지막, 즉 Top으로만 Push가 가능하며, 역시 Top에서만 Pop이 가능하다.

그러니, Stack끝에 포인터만 유지하면, Push및 Pop을 구현 할 수 있게 됩니다. 이 포인터를 Stack 포인터라고 부른다.

그래서 우리가 함수를 호출 할 때, 우리는 메모리를 일단 먼저 할당해야할텐데 그 메모리를 단순히 Stack 포인터가 가리키고 있는 곳을 단순히 줄임(decrementing)으로써 필요한 메모리를 할당 할 수 있다. 그리고 함수가 끝나면, Stack 포인터를 줄이기 전에 있던 곳으로 증가(incrementing)시킴으로써 그 메모리 할당을 해제할 수 있다.

스택은 메모리에 할당하지 않기때문에 성능에 좋다. (그래서 값타입을 애플이 유도하는 것이다.)

![](Pasted%20image%2020240423001631.png)

하지만 스택과 대조적으로 힙이라는 데이터 구조가 있는데 힙보다 좀 더 동적이지만 효율은 스택보다 좋지않다.

힙을 사용하면 스택이 할 수 없는 일을 할 수 있다. 바로 dynamic lifetime을 가진 메모리를 할당할 수 있다.

![](Pasted%20image%2020240423001733.png)

힙에 메모리를 할당하려면, 실제로 힙 데이터 구조를 검색하여 사용되지 않는 적절한 크기의 블록을 찾아야한다.(일정 공간을 사용해야하기 때문에) 그리고 할당을 해제하려면 해당 메모리를 또 적절한 위치로 재삽입을 해야한다.

여기서 가장 큰 복잡함은 여러 쓰레드가 동시에 힙에 메모리를 할당할 수 있기 때문에, 힙은 lock 또는 기타 동기화 메커니즘을 사용해서 무결성을 보호해야 한다. -> 이것이 힙 할당에서 가장 큰 비용

![](Pasted%20image%2020240423002203.png)

`Point`라는 구조체를 살펴보면 프로퍼티와 메소드가 있다. point1에 Point의 인스턴스를 할당하고, point2에 point1을 복사하고, point2.x 에 5를 할당한다.

![](Pasted%20image%2020240423003852.png)

그러면 코드가 실행되기 전에 point1과 point2의 인스턴스를 스택에 할당하면 스택의 line에 저장된다.( x and y properties are stored in line on the stack)

![](Pasted%20image%2020240423004106.png)

따라서 우리가 Point의 인스턴스를 생성할 때 스택에 이미 할당한 메모리를 초기화 하는 것 뿐이다. 그리고 point2에 point1을 복사해서 할당할 때, 우리는 해당 point의 복사본을 만들고 스택상에 이미 할당한 메모리를 다시 초기화하는 것이다.

즉, point1과 point2는 독립적인 인스턴스다.

그리고 point2.x에 5를 넣는다면

![](Pasted%20image%2020240423004220.png)

우리가 point1을 사용하고, point2를 사용하고 이제 다 끝나면, 스택 포인터를 점차적으로 증가시키면 point1과 point2에 대한 메모리 할당을 쉽게 해제 할 수 있게 된다.

그렇다면 Point를 클래스로 선언하면 

![](Pasted%20image%2020240423004327.png)

그림이 조금 달라졌는데 코드를 실행하기 전에 컴파일러는 이미 스택에 point1, point2에 대한 메모리 할당이 된다. 하지만 실제로 아까처럼 스택의 line에 프로퍼티를 저장하는 것이 아닌, **point1과 point2에 대한 레퍼런스를 위해** 메모리에 할당(포인터) 즉, 힙에 할당할 메모리에 대한 참조이다.

따라서 Point의 인스턴스를 생성하면, Swift는 힙을 lock하고(무결성을 위해) 해당 크기의 메모리를 **검색**한다.

![](Pasted%20image%2020240423004525.png)

공간을 찾는다면?

![](Pasted%20image%2020240423004549.png)

![](Pasted%20image%2020240423004600.png)

이렇게 힙 영역에 대한 주소값을 스택에 저장한다. 그리고 point2.x의 값을 바꾼다면

![](Pasted%20image%2020240423004633.png)

주소값을 찾아가 해당 영역에서 x 의 값을 변경하게 된다.

이렇게 되면 point1, point2 둘 다 x의 값이 5로 변경될 것이다.

근데 여기서 이상한점이 하나 있을텐데 현재 Point 클래스는 x,y 2개의 프로퍼티만 존재하는데 힙 영역을 4칸이나 사용하고 있다. 이유는 x,y 외에도 Swift가 대신하여 관리하기 위한 공간을 할당하기 때문이다.

이제 point1, point2를 모두 사용하고 메모리에 해제된다면 

![](Pasted%20image%2020240423004825.png)

그러면 Swift는 또 힙을 잠그고 사용하지 않은 블록들을 적절한 위치로 재삽입(reinsert)한다.

![](Pasted%20image%2020240423004851.png)

그리고 나서 스택을 pop할 수 있다.

클래스는 힙 할당이 필요로하기 때문에 클래스가 구조체보다 더 많은 비용이 든다. 클래스는 힙에 할당하고 레퍼런스 체계를 가지므로 ID 및 간접 저장소와 같은 특성이 있다.

근데 우리가 추상화할 때 이런 특성이 필요 없다면 구조체를 사용하는 것이 좋다!

그래서 세션의 또 다른 예를 살펴보면

![](Pasted%20image%2020240423005042.png)

![](Pasted%20image%2020240423005050.png)

열거형을 이용하여 여러 모양의 말풍선을 만드는 코드이다.

![](Pasted%20image%2020240423005111.png)

여기서 `makeBallon(_:orientaition:tail:)` 메소드는 사용자가 스크롤 중에 빈번히 호출한다고 가정하면 빠를 필요가 있고 캐시를 딕셔너리로 만들었다. 즉, 같은 말풍선을 한번 더 만들 필요가 없게,,, 그래서 만들어졌다면 꺼내서 쓰게

[String, UIIamge] 타입의 딕셔너리에서 Key의 타입인 String은 강력한 타입이 아니다. 실제로 정확한 값이 아닌 아무 값이나 넣을 수 있기 때문에 안전하지 않다. 또한 String은 실제로 힙에 간접적으로 캐릭터들의 contents를 저장하기 때문에 많은 것을 나타낼 수 있다. 즉, 캐시를 딕셔너리로 만들었지만 캐시가 히트 되어도 힙 할당이 발생할 수 있다는 것이다.

이것을 개선해보면

![](Pasted%20image%2020240423005346.png)

`Attributes`라는 **구조체**를 만들고 딕셔너리의 키가 될 수 있도록 Hasahble 프로토콜을 준수했다.
이제 그러면 `Attributes`는 구조체기 때문에 스택의 line에 프로퍼티들을 할당할 것이다. 결국 String을 사용했을 때는 힙에 할당하던걸 구조체로 변경하여 힙에 할당하지 않게 리팩토링하여 메모리 할당에 대한 오버헤드를 없앴다. 이렇게 하면 좀 더 안전하고 성능이 좋은 코드를 작성할 수 있다.
## Reference Counting
Swift에서 힙에 할당된 메모리를 할당 해제하는 것이 **안전**하다는 것은 힙에 있는 레퍼런스 카운트를 통해 체크한다.
레퍼런스 카운트에 대해서는(다들 아실거니,,,) 간단하게 설명하면 레퍼런스를 추가하면 +1 제거하면 -1 0이 되면 메모리에서 할당 해제된다.

![](Pasted%20image%2020240423005740.png)

레퍼런스 카운팅에서 염두해야 하는 것은 +1, -1 하는 것 이상으로 카운팅 작업이 빈번히 실행된다. 먼저, 단순히 증가/감소를 위해 몇가지 간접적인 단계가 있다. 그러나 힙 할당과 마찬가지로, 레퍼런스가 여러 쓰레드에 의해 동시에 추가/제거 될 수 있기 때문에 쓰레드 안전성을 고려해야 한다. 실제로 원자적으로(분리할 수 없게) 레퍼런스 카운트가 증가/감소 되어야 한다. 그리고 레퍼런스 카운팅의 빈도로 인해 비용이 증가할 수 있다.

앞에서 사용했던 Point 클래스로 예제를 살펴보면

![](Pasted%20image%2020240423010009.png)

클래스이므로 힙 할당이 일어날 것이고 레퍼런스 카운트가 있게 될 것이다.

![](Pasted%20image%2020240423010035.png)

컴파일러가 이렇게 코드를 우리는 보이지 않게 코드를 삽입한다. retain은 +1, release는 -1 

좀 더 살펴보면 

![](Pasted%20image%2020240423010228.png)

위에서 봤다 시피 똑같이 만들어지는데 두 번재 칸에 이제 refCount가 할당된다.

![](Pasted%20image%2020240423010249.png)

모두 참조가 끝나면 힙에서 할당 해제하고 재삽입 후 스택도 모두 pop시킨다.

좀 더 복잡한 다른 예제를 살펴보면

![](Pasted%20image%2020240423010346.png)

`Label` 이라는 구조체를 만들고 그 안에 String, UIFont(class) 타입이 들어있다. 앞에서 말했다시피 Strings은 contents를 힙에 저장하게 된다 그러면 두 프로퍼티 모두 힙에 저장하게 되는데, 그렇다면 두 프로퍼티 모두 레퍼런스 카운트를 계산해야 한다는 것이다.

![](Pasted%20image%2020240423010515.png)

우선 똑같이 스택에 공간을 할당하고 여기에 레퍼런스를 저장한다.

![](Pasted%20image%2020240423010602.png)

컴파일러가 생성하는 코드는 위와 같이 될 것이다. label1을 label2에 넣고 각 프로퍼티에 대한 retain을 해주면서 카운트를 증가시키고, 각각 다 쓰면 각 프로퍼티들을 release 해준다. 결국 프로퍼티 둘 다 힙에 저장되니 다 2번씩 해줘야한다는 점이다. 이렇게 오버헤드가 커지게 된다.

실제로 구조체 안에 이렇게 레퍼런스가 있는 경우, **레퍼런스 수에 비례하여 레퍼런스 카운팅 오버헤드를 지불학레 되며, 둘 이상의 레퍼런스가 있는 경우, 클래스보다 레퍼런스 카운팅 오버헤드가 더 많이 유지된다.** -> 이런 경우는 클래스로 만들어라 그냥

다른 예제를 살펴보면

![](Pasted%20image%2020240423011031.png)

메세지 첨부 기능을 추상화한 `Attachment`라는 구조체를 만들었다. 구조체로 선언했지만 각각의 프로퍼티들이 모두 힙에 할당되는 상황이다...

그렇다면 어떻게 해결하는게 좋을까..? uuid를 보면

![](Pasted%20image%2020240423011106.png)

iOS6 부터, UUID라는 구조체 타입이 추가되었는데, 고유하게 식별하는데 쓰기 좋은 구조체라고 한다.

![uuid](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F999D02355BA4DBD216)
이제 mimeType을 살펴보면 

![](Pasted%20image%2020240423011216.png)

기존에는 String을 확장하여 적용했는데

![](Pasted%20image%2020240423011236.png)

열거형을 이용해 힙에 할당하지 않게 저장하도록 한다.

그러면 이제 다시 보면

![](Pasted%20image%2020240423011303.png)

`fileURL` 하나만 힙 할당을 하면 된다...! 이렇게 하면 성능이 좀 더 좋아질 것이다.
## Method dispatch
런타임에 메소드를 호출하면, Swift는 정확한 구현을 실행해야 한다. 컴파일 타임에 어떤 구현을 실행하도록 결정할 수 있다면, 이를 **정적 디스패치**라고 한다.
컴파일러가 실제로 어떤 구현이 실행될건지 알고 있기 때문이다. 즉, inline과 같은 것을 포함하여 코드를 적극저으로 최적화 할 수 있게 된다.

![](Pasted%20image%2020240425232835.png)

이러한 정적 디스패치에 대척점에 서있는게 동적 디스패치이다.
동적 디스패치는 컴파일러가 컴파일 타임에 어떤 구현을 실행할건지 결정할 수 없다. 런타임때만 실제로 구현된 곳으로 **jump**하게 된다. 따라서 동적 디스패치의 비용은 정적 디스패치보다 훨씬 크다.

![](Pasted%20image%2020240425232846.png)

예제를 살펴보

![](Pasted%20image%2020240426001112.png)

`Point`라는 구조체가 선언되어있고 `Point`의 인스턴스를 만들고, `drawPoint()`라는 함수를 호출하면, 그 함수 안에서 `Point`의 인스턴스 메소드인 `draw()`를 호출한다.

`drawPoint()`, `draw()` 메소드 둘 다 정적 디스패치 되므로 컴파일러가 정확히 어떤 구현이 실행될 것인지를 정확하게 알고 있으므로 최적화를 실행하여 인라인 형태로 수행된다.

![](Pasted%20image%2020240426001330.png)

위의 사진처럼 `drawPoint(_:)` 대신 `point.draw()`가 들어가게 된다. 그리고 또 다시 최적화하여 함수 내부의 코드가 그대로 다시 들어간다. 이렇게 하면 함수로 찾아가지 않고 코드가 아래로 내려가게 된다.

![](Pasted%20image%2020240426002003.png)

그러면 동적 디스패치는 왜 쓰는걸까? 그 이유 중 하나는 다형성과 같은 것들이 가능하다는 것 때문이다.

![](Pasted%20image%2020240426002533.png)

`Drawable`이라는 클래스를 선언하고 `Point`, `Line` 클래스는 `Drawable`을 상속하도록 한다.

![](Pasted%20image%2020240426002635.png)

그리고 `Array<Drawable>` 타입의 배열을 만들면 배열 안에서 이들에 대한 참조를 저장하기 때문에 모두 같은 크기이다.

![](Pasted%20image%2020240426003232.png)

그리고 실제로 배열의 요소들은 실제로 힙에 있는 것을 가르키고 `refCount`를 자체적으로 갖게 된다.

![](Pasted%20image%2020240426003311.png)

이제 for loop를 순회하면서 `Drawable`의 `draw()`를 호출하게 된다. 컴파일러가 여기서 정확히 어떤 구현을 실행해야하는지, 즉 `Line`의 `draw()`인지 `Point`의 `draw()`인지를 알기 위해서는 런타임에 알 수 있게 된다는 것이다. 그럼 컴파일러는 어떤 `draw()`를 호출해야하는지 어떻게 결정하는가
컴파일러는 그 클래스 타입 정보에 대한 것을 정적 메모리에 저장하고, 실제로 `draw()`를 호출할 때, 컴파일러가 실제로 생성하는 것은 타입 및 정적 메모리의 가상 메소드 테이블이라고 하는 것(== vtable)을 조회한다. 그리고 실행하기에 적합한 `draw()`를 찾고, 그리고 나서 파라미터로 실제 인스턴스를 전달한다.

그러면 결과적으로 우리는 클래스가 기본적으로 동적 디스패치를 한다는 것을 알고있습니다. 자체적으로 큰 차이를 만들지는 않지만, 메소드 체인, 인라인과 같은 최적화를 막을 수 있다. 하지만 모든 클래스가 이 동적 디스패치를 사용할 필요는 없는데 바로 final로 명시하여 상속받지 못하게 하면된다. 컴파일러는 이를 보고 정적 디스패치를 하게 될 것이다.
또한 컴파일러가 앱에서 클래스를 상속하지 않을 것이라는 추론을 입증 할 수 있다면, 기회를 보고 동적 디스패치 대신 정적 디스패치를 하게 된다.