Session: https://developer.apple.com/videos/play/wwdc2016/416/
Ref: https://zeddios.tistory.com/596#recentComments
## Dimensions of Performance
![](Pasted%20image%2020240423001321.png)

### Allocation
Swift는 자동으로 메모리를 할당하고, 해제하는데 메모리 중 일부는 Stack에 할당된다.

다들 아시다시피, Stack은 LIFO구조로 매우 단순한 데이터 구조다.

Stack의 마지막, 즉 Top으로만 Push가 가능하며, 역시 Top에서만 Pop이 가능하다.

그러니, Stack끝에 포인터만 유지하면, Push및 Pop을 구현 할 수 있게 됩니다. 이 포인터를 Stack 포인터라고 부른다.

그래서 우리가 함수를 호출 할 때, 우리는 메모리를 일단 먼저 할당해야할텐데 그 메모리를 단순히 Stack 포인터가 가리키고 있는 곳을 단순히 줄임(decrementing)으로써 필요한 메모리를 할당 할 수 있다. 그리고 함수가 끝나면, Stack 포인터를 줄이기 전에 있던 곳으로 증가(incrementing)시킴으로써 그 메모리 할당을 해제할 수 있다.

스택은 메모리에 할당하지 않기때문에 성능에 좋다. (그래서 값타입을 애플이 유도하는 것이다.)

![](Pasted%20image%2020240423001631.png)

하지만 스택과 대조적으로 힙이라는 데이터 구조가 있는데 힙보다 좀 더 동적이지만 효율은 스택보다 좋지않다.

힙을 사용하면 스택이 할 수 없는 일을 할 수 있다. 바로 dynamic lifetime을 가진 메모리를 할당할 수 있다.

![](Pasted%20image%2020240423001733.png)

힙에 메모리를 할당하려면, 실제로 힙 데이터 구조를 검색하여 사용되지 않는 적절한 크기의 블록을 찾아야한다.(일정 공간을 사용해야하기 때문에) 그리고 할당을 해제하려면 해당 메모리를 또 적절한 위치로 재삽입을 해야한다.

여기서 가장 큰 복잡함은 여러 쓰레드가 동시에 힙에 메모리를 할당할 수 있기 때문에, 힙은 lock 또는 기타 동기화 메커니즘을 사용해서 무결성을 보호해야 한다. -> 이것이 힙 할당에서 가장 큰 비용

![](Pasted%20image%2020240423002203.png)

`Point`라는 구조체를 살펴보면 프로퍼티와 메소드가 있다. point1에 Point의 인스턴스를 할당하고, point2에 point1을 복사하고, point2.x 에 5를 할당한다.

![](Pasted%20image%2020240423003852.png)

그러면 코드가 실행되기 전에 point1과 point2의 인스턴스를 스택에 할당하면 스택의 line에 저장된다.( x and y properties are stored in line on the stack)

![](Pasted%20image%2020240423004106.png)

따라서 우리가 Point의 인스턴스를 생성할 때 스택에 이미 할당한 메모리를 초기화 하는 것 뿐이다. 그리고 point2에 point1을 복사해서 할당할 때, 우리는 해당 point의 복사본을 만들고 스택상에 이미 할당한 메모리를 다시 초기화하는 것이다.

즉, point1과 point2는 독립적인 인스턴스다.

그리고 point2.x에 5를 넣는다면

![](Pasted%20image%2020240423004220.png)

우리가 point1을 사용하고, point2를 사용하고 이제 다 끝나면, 스택 포인터를 점차적으로 증가시키면 point1과 point2에 대한 메모리 할당을 쉽게 해제 할 수 있게 된다.

그렇다면 Point를 클래스로 선언하면 

![](Pasted%20image%2020240423004327.png)

그림이 조금 달라졌는데 코드를 실행하기 전에 컴파일러는 이미 스택에 point1, point2에 대한 메모리 할당이 된다. 하지만 실제로 아까처럼 스택의 line에 프로퍼티를 저장하는 것이 아닌, **point1과 point2에 대한 레퍼런스를 위해** 메모리에 할당(포인터) 즉, 힙에 할당할 메모리에 대한 참조이다.

따라서 Point의 인스턴스를 생성하면, Swift는 힙을 lock하고(무결성을 위해) 해당 크기의 메모리를 **검색**한다.

![](Pasted%20image%2020240423004525.png)

공간을 찾는다면?

![](Pasted%20image%2020240423004549.png)

![](Pasted%20image%2020240423004600.png)

이렇게 힙 영역에 대한 주소값을 스택에 저장한다. 그리고 point2.x의 값을 바꾼다면

![](Pasted%20image%2020240423004633.png)

주소값을 찾아가 해당 영역에서 x 의 값을 변경하게 된다.

이렇게 되면 point1, point2 둘 다 x의 값이 5로 변경될 것이다.

근데 여기서 이상한점이 하나 있을텐데 현재 Point 클래스는 x,y 2개의 프로퍼티만 존재하는데 힙 영역을 4칸이나 사용하고 있다. 이유는 x,y 외에도 Swift가 대신하여 관리하기 위한 공간을 할당하기 때문이다.

이제 point1, point2를 모두 사용하고 메모리에 해제된다면 

![](Pasted%20image%2020240423004825.png)

그러면 Swift는 또 힙을 잠그고 사용하지 않은 블록들을 적절한 위치로 재삽입(reinsert)한다.

![](Pasted%20image%2020240423004851.png)

그리고 나서 스택을 pop할 수 있다.

클래스는 힙 할당이 필요로하기 때문에 클래스가 구조체보다 더 많은 비용이 든다. 클래스는 힙에 할당하고 레퍼런스 체계를 가지므로 ID 및 간접 저장소와 같은 특성이 있다.

근데 우리가 추상화할 때 이런 특성이 필요 없다면 구조체를 사용하는 것이 좋다!

그래서 세션의 또 다른 예를 살펴보면

![](Pasted%20image%2020240423005042.png)

![](Pasted%20image%2020240423005050.png)

열거형을 이용하여 여러 모양의 말풍선을 만드는 코드이다.

![](Pasted%20image%2020240423005111.png)

여기서 `makeBallon(_:orientaition:tail:)` 메소드는 사용자가 스크롤 중에 빈번히 호출한다고 가정하면 빠를 필요가 있고 캐시를 딕셔너리로 만들었다. 즉, 같은 말풍선을 한번 더 만들 필요가 없게,,, 그래서 만들어졌다면 꺼내서 쓰게

[String, UIIamge] 타입의 딕셔너리에서 Key의 타입인 String은 강력한 타입이 아니다. 실제로 정확한 값이 아닌 아무 값이나 넣을 수 있기 때문에 안전하지 않다. 또한 String은 실제로 힙에 간접적으로 캐릭터들의 contents를 저장하기 때문에 많은 것을 나타낼 수 있다. 즉, 캐시를 딕셔너리로 만들었지만 캐시가 히트 되어도 힙 할당이 발생할 수 있다는 것이다.

이것을 개선해보면

![](Pasted%20image%2020240423005346.png)

`Attributes`라는 **구조체**를 만들고 딕셔너리의 키가 될 수 있도록 Hasahble 프로토콜을 준수했다.
이제 그러면 `Attributes`는 구조체기 때문에 스택의 line에 프로퍼티들을 할당할 것이다. 결국 String을 사용했을 때는 힙에 할당하던걸 구조체로 변경하여 힙에 할당하지 않게 리팩토링하여 메모리 할당에 대한 오버헤드를 없앴다. 이렇게 하면 좀 더 안전하고 성능이 좋은 코드를 작성할 수 있다.
## Reference Counting
Swift에서 힙에 할당된 메모리를 할당 해제하는 것이 **안전**하다는 것은 힙에 있는 레퍼런스 카운트를 통해 체크한다.
레퍼런스 카운트에 대해서는(다들 아실거니,,,) 간단하게 설명하면 레퍼런스를 추가하면 +1 제거하면 -1 0이 되면 메모리에서 할당 해제된다.

![](Pasted%20image%2020240423005740.png)

레퍼런스 카운팅에서 염두해야 하는 것은 +1, -1 하는 것 이상으로 카운팅 작업이 빈번히 실행된다. 먼저, 단순히 증가/감소를 위해 몇가지 간접적인 단계가 있다. 그러나 힙 할당과 마찬가지로, 레퍼런스가 여러 쓰레드에 의해 동시에 추가/제거 될 수 있기 때문에 쓰레드 안전성을 고려해야 한다. 실제로 원자적으로(분리할 수 없게) 레퍼런스 카운트가 증가/감소 되어야 한다. 그리고 레퍼런스 카운팅의 빈도로 인해 비용이 증가할 수 있다.

앞에서 사용했던 Point 클래스로 예제를 살펴보면

![](Pasted%20image%2020240423010009.png)

클래스이므로 힙 할당이 일어날 것이고 레퍼런스 카운트가 있게 될 것이다.

![](Pasted%20image%2020240423010035.png)

컴파일러가 이렇게 코드를 우리는 보이지 않게 코드를 삽입한다. retain은 +1, release는 -1 

좀 더 살펴보면 

![](Pasted%20image%2020240423010228.png)

위에서 봤다 시피 똑같이 만들어지는데 두 번재 칸에 이제 refCount가 할당된다.

![](Pasted%20image%2020240423010249.png)

모두 참조가 끝나면 힙에서 할당 해제하고 재삽입 후 스택도 모두 pop시킨다.

좀 더 복잡한 다른 예제를 살펴보면

![](Pasted%20image%2020240423010346.png)

`Label` 이라는 구조체를 만들고 그 안에 String, UIFont(class) 타입이 들어있다. 앞에서 말했다시피 Strings은 contents를 힙에 저장하게 된다 그러면 두 프로퍼티 모두 힙에 저장하게 되는데, 그렇다면 두 프로퍼티 모두 레퍼런스 카운트를 계산해야 한다는 것이다.

![](Pasted%20image%2020240423010515.png)

우선 똑같이 스택에 공간을 할당하고 여기에 레퍼런스를 저장한다.

![](Pasted%20image%2020240423010602.png)

컴파일러가 생성하는 코드는 위와 같이 될 것이다. label1을 label2에 넣고 각 프로퍼티에 대한 retain을 해주면서 카운트를 증가시키고, 각각 다 쓰면 각 프로퍼티들을 release 해준다. 결국 프로퍼티 둘 다 힙에 저장되니 다 2번씩 해줘야한다는 점이다. 이렇게 오버헤드가 커지게 된다.

실제로 구조체 안에 이렇게 레퍼런스가 있는 경우, **레퍼런스 수에 비례하여 레퍼런스 카운팅 오버헤드를 지불학레 되며, 둘 이상의 레퍼런스가 있는 경우, 클래스보다 레퍼런스 카운팅 오버헤드가 더 많이 유지된다.** -> 이런 경우는 클래스로 만들어라 그냥

다른 예제를 살펴보면

![](Pasted%20image%2020240423011031.png)

메세지 첨부 기능을 추상화한 `Attachment`라는 구조체를 만들었다. 구조체로 선언했지만 각각의 프로퍼티들이 모두 힙에 할당되는 상황이다...

그렇다면 어떻게 해결하는게 좋을까..? uuid를 보면

![](Pasted%20image%2020240423011106.png)

iOS6 부터, UUID라는 구조체 타입이 추가되었는데, 고유하게 식별하는데 쓰기 좋은 구조체라고 한다.

![uuid](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F999D02355BA4DBD216)
이제 mimeType을 살펴보면 

![](Pasted%20image%2020240423011216.png)

기존에는 String을 확장하여 적용했는데

![](Pasted%20image%2020240423011236.png)

열거형을 이용해 힙에 할당하지 않게 저장하도록 한다.

그러면 이제 다시 보면

![](Pasted%20image%2020240423011303.png)

`fileURL` 하나만 힙 할당을 하면 된다...! 이렇게 하면 성능이 좀 더 좋아질 것이다.
## Method dispatch
