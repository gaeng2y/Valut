오늘의 문제: [4693번 섬의 개수](https://www.acmicpc.net/problem/4693)
- 오늘의 학습 키워드
  -  DFS (Depth-First Search, 깊이 우선 탐색)
    - 개념: 그래프나 트리 구조를 탐색하는 알고리즘 중 하나입니다. 시작 노드에서 출발하여 한 방향으로 최대한 깊이 들어간 후, 더 이상 갈 곳이 없으면 막다른 길에서 이전 갈림길로 돌아와 다른 방향으로 탐색을 이어가는 방식입니다.
    - 특징
      - 스택(Stack) 자료구조 또는 재귀 함수를 이용하여 구현합니다. (제공된 코드는 재귀 함수를 사용합니다.)
      - 현재 경로상의 노드들만 기억하면 되므로 상대적으로 적은 메모리를 사용합니다.
      - 모든 노드를 방문해야 하는 경우에 주로 사용됩니다.
      - 경로의 특징을 저장해야 하는 문제 (예: 백트래킹)에 유리합니다.
      - 간단 비유: 미로 찾기를 할 때, 한 갈림길에서 막힐 때까지 계속 한 방향으로만 가다가 막히면 이전 갈림길로 돌아와 다른 길로 가보는 것과 비슷합니다.
  - BFS (Breadth-First Search, 너비 우선 탐색)
    - 개념: 그래프나 트리 구조를 탐색하는 또 다른 알고리즘입니다. 시작 노드에서 출발하여 가까운 노드들을 먼저 방문하고, 그 다음으로 가까운 노드들을 방문하는 방식으로, 마치 물결이 퍼져나가듯이 탐색합니다.
    - 특징:
      - 큐(Queue) 자료구조를 이용하여 구현합니다.
      - 시작 노드에서 다른 모든 노드까지의 최단 경로(간선 수가 가장 적은 경로)를 찾는 데 유용합니다.
      - DFS보다 많은 메모리를 필요로 할 수 있습니다 (특히 넓게 퍼지는 그래프의 경우).
      - 간단 비유: 연못에 돌을 던졌을 때 물결이 동심원을 그리며 퍼져나가는 모습이나, 소셜 네트워크에서 내 친구들을 먼저 다 찾고, 그 다음 친구들의 친구들을 찾는 과정과 비슷합니다.
- 공부한 내용 본인의 언어로 정리하기
```swift
import Foundation

// 상하좌우 왼쪽위 왼쪽아래 오른쪽위 오른쪽아래
let dx = [-1, 1, 0, 0, -1, 1, -1, 1]
let dy = [0, 0, -1, 1, -1, -1, 1, 1]

while true {
    let wh = readLine()!.split(separator: " ").map{ Int($0)! }

    if wh == [0, 0] {
        break
    }

    var islandMap = [[Int]]()
    for _ in 0..<wh[1] {
        islandMap.append(readLine()!.split(separator: " ").map{ Int($0)! })
    }

    // MARK: - DFS 함수
    func dfs(x: Int, y: Int) -> Bool {
        if x < 0 || x >= wh[1] || y < 0 || y >= wh[0] {
            return false
        }

        if islandMap[x][y] == 1 {
            islandMap[x][y] = 0
            for i in 0..<8 {
                let nx = x + dx[i]
                let ny = y + dy[i]
                dfs(x: nx, y: ny)
            }
            return true
        }
        return false
    }

    // MARK: - main
    var result = 0
    for i in 0..<wh[1] {
        for j in 0..<wh[0] {
            if dfs(x: i, y: j) {
                result += 1
            }
        }
    }
    print(result)
}
```
- 오늘의 회고
  - 이 코드는 2차원 격자 지도에서 '섬'의 개수를 세는 전형적인 문제입니다. 여기서 '섬'은 상하좌우 및 대각선으로 연결된 땅(1)들의 덩어리를 의미합니다. 코드는 DFS를 사용하여 이 문제를 해결합니다.
1. 초기 설정:
      - dx, dy: 현재 위치에서 이동할 수 있는 8가지 방향(상하좌우, 대각선)을 정의합니다. dx는 행(세로) 변화량, dy는 열(가로) 변화량을 나타냅니다.
2. 입력 처리 (while 루프):
  - while true: 너비(w)와 높이(h)가 [0, 0]이 입력될 때까지 계속 반복합니다.
  - readLine()!.split(separator: " ").map{ Int($0)! }: 한 줄을 읽어 공백으로 구분하고, 각 부분을 정수로 변환하여 배열로 만듭니다. 첫 번째 줄에서는 지도의 너비(wh[0])와 높이(wh[1])를 읽습니다.
  - if wh == [0, 0] { break }: 너비와 높이가 모두 0이면 루프를 종료합니다.
  - islandMap = [[Int]](): 지도를 저장할 2차원 배열을 초기화합니다.
  - for _ in 0..<wh[1]: 높이만큼 반복하며 지도 정보를 읽어 islandMap에 추가합니다. 각 줄은 땅(1) 또는 물(0)을 나타내는 정수 배열입니다.
3. DFS 함수 (dfs(x: Int, y: Int) -> Bool):
  - 목적: 특정 좌표 (x, y)에서 시작하여 연결된 모든 땅(1)을 방문하고, 방문한 땅은 0으로 바꿔 다시 방문하지 않도록 표시합니다.
  - 경계 검사: if x < 0 || x >= wh[1] || y < 0 || y >= wh[0]: 현재 좌표 (x, y)가 지도의 범위를 벗어나면 탐색을 중단하고 false를 반환합니다. (wh[1]은 높이(행 개수), wh[0]은 너비(열 개수)입니다.)
  - 땅(1) 발견 및 방문 처리: if islandMap[x][y] == 1: 현재 위치가 땅(1)인 경우
    - islandMap[x][y] = 0: 현재 땅을 방문했음을 표시하기 위해 0으로 바꿉니다. (이것이 핵심! 다시 방문하지 않도록 합니다.)
    - for i in 0..<8: 8가지 방향에 대해 반복합니다.
    - let nx = x + dx[i], let ny = y + dy[i]: 다음 이동할 좌표 (nx, ny)를 계산합니다.
    - dfs(x: nx, y: ny): 계산된 다음 좌표로 재귀 호출하여 깊이 우선 탐색을 계속 진행합니다. 연결된 모든 땅을 찾아 0으로 만들 때까지 이 과정이 반복됩니다.
    - return true: 이 dfs 호출이 땅(1)에서 시작되었음을 알립니다. 즉, 새로운 섬의 일부를 찾았거나, 기존 섬 탐색을 계속 진행했음을 의미합니다.
  - 물(0) 또는 이미 방문한 땅: return false: 현재 위치가 물(0)이거나 이미 방문 처리된 땅(0)이면 탐색할 필요가 없으므로 false를 반환합니다.
4. 메인 로직 (섬 개수 세기):
  - result = 0: 섬의 개수를 저장할 변수를 초기화합니다.
  - for i in 0..<wh[1]: 지도의 모든 행(세로)을 순회합니다.
  - for j in 0..<wh[0]: 지도의 모든 열(가로)을 순회합니다.
  - if dfs(x: i, y: j): 현재 좌표 (i, j)에서 dfs를 호출합니다.
    - 만약 dfs가 true를 반환하면: 이는 (i, j)가 아직 방문하지 않은 땅(1)이었고, 이 땅을 시작으로 연결된 모든 땅 덩어리(하나의 섬)를 dfs 함수 내에서 모두 방문 처리(0으로 변경)했다는 의미입니다. 따라서 새로운 섬 하나를 발견한 것이므로 result를 1 증가시킵니다.
    - 만약 dfs가 false를 반환하면: 이는 (i, j)가 물(0)이거나, 이전에 다른 dfs 호출을 통해 이미 방문된 땅(0으로 바뀐 상태)이라는 의미이므로 result를 증가시키지 않습니다.
  - print(result): 현재 지도에 대한 최종 섬의 개수를 출력합니다.
#### 요약
이 코드는 지도의 모든 칸을 하나씩 확인하면서, 만약 아직 방문하지 않은 땅(1)을 만나면 DFS를 시작합니다. DFS는 그 땅과 연결된 모든 땅을 찾아 0으로 만들고 true를 반환합니다. true가 반환될 때마다 섬의 개수를 하나씩 세는 방식으로 동작합니다.

#99클럽 #코딩테스트준비 #개발자취업 #항해99 #TIL