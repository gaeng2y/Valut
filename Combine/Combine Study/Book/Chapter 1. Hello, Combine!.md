### Foundation과 UIKit/AppKit

애플은 자사 플랫폼을 위한 비동기 프로그래밍을 계속 개선해왔어. 다양한 시스템 레벨에서 비동기 코드를 생성하고 실행할 수 있는 몇 가지 메커니즘을 만들었지. 이런 것들을 모바일 앱을 작성할 때 기본적으로 많이 사용하니까 아마 의식하지 않고도 너의 프로젝트에서 사용해봤을 거야.

다음과 같은 것들을 사용해봤을 가능성이 높아:
- **NotificationCenter**: 사용자가 기기의 방향을 변경하거나 소프트웨어 키보드가 화면에 나타나거나 사라질 때처럼, 관심 있는 이벤트가 발생할 때마다 코드를 실행하도록 해줘.
- **델리게이트 패턴**: 다른 객체를 대신해서, 또는 다른 객체와 협력하여 행동하도록 객체를 정의할 수 있게 해. 예를 들어, 앱 델리게이트에서 새로운 원격 알림이 도착했을 때 무슨 일이 일어나야 할지를 정의하지만, 이 코드가 언제 실행될지 또는 몇 번 실행될지는 알 수 없지.
- **Grand Central Dispatch와 Operations**: 작업을 실행하는 것을 추상화할 수 있어. 순차적으로 코드를 실행하도록 일련의 큐에 스케줄을 잡거나, 다양한 우선순위를 가진 다른 큐에서 동시에 많은 작업을 실행할 수 있도록 도와줘.
- **클로저**: 코드에서 다른 객체가 그것을 실행할지, 몇 번 실행할지, 어떤 맥락에서 실행할지 결정할 수 있도록 코드 조각을 생성하고 전달할 수 있어.

대부분의 전형적인 코드는 어떤 형태로든 비동기적으로 일부 작업을 수행하고, 모든 UI 이벤트는 본질적으로 비동기적이기 때문에, 앱 코드가 전체적으로 어떤 순서로 실행될지 가정하는 것은 불가능해.

그렇지만 좋은 비동기 프로그램을 작성하는 것은 가능해. 단지, 우리가 원하는 것보다 좀 더 복잡할 뿐이야. 불행히도 비동기 코드와 자원 공유는 재현하거나 추적하고 마침내 수정하기 어려운 문제들을 야기할 수 있어.

이 문제들의 원인 중 하나는 실제로 사용되는 앱이 각기 다른 인터페이스를 가진 여러 종류의 비동기 API를 모두 사용한다는 사실이야. 예를 들어, Combine은 Swift 생태계에 새로운 언어를 도입하려고 해. 이는 비동기 프로그래밍 세계의 혼돈에 더 많은 질서를 가져오는 데 도움을 줄 수 있어.
### Foundation of Combine

iOS 13과 macOS Catalina에서 애플은 내장 시스템 프레임워크인 Combine을 통해 자사 생태계에 반응형 프로그래밍 지원을 도입했어. 애플의 새로운 기술과 마찬가지로 처음에는 그 적용이 약간 제한적이야: Combine은 iOS 13 또는 macOS Catalina 이상을 지원하는 앱에서만 사용할 수 있어.

### Combine basics
#### Publisher
퍼블리셔는 시간이 지남에 따라 하나 이상의 관심 있는 구독자에게 값을 발행할 수 있는 타입이야. 퍼블리셔의 내부 로직은 수학 계산, 네트워킹, 사용자 이벤트 처리를 포함하여 거의 무엇이든 될 수 있지만, 모든 퍼블리셔는 세 가지 유형의 이벤트를 여러 번 발행할 수 있어:

1. 퍼블리셔의 제네릭 Output 타입의 출력 값.
2. 성공적인 완료.
3. 퍼블리셔의 Failure 타입에 대한 에러와 함께 완료.

퍼블리셔는 0개 이상의 출력 값을 발행할 수 있으며, 성공적으로 또는 실패로 인해 완료되면 다른 이벤트는 발행하지 않아.

여기에 Int 값을 발행하는 퍼블리셔가 시간 축에 시각화된 모습을 보여줄게: 

![](Pasted%20image%2020240703225012.png)

파란 상자는 타임라인에서 주어진 시간에 발행된 값을 나타내고, 숫자는 발행된 값을 나타내. 다이어그램 오른쪽에 보이는 세로선은 스트림의 성공적인 완료를 나타내.

이 세 가지 가능한 이벤트의 간단한 계약은 프로그램에서 어떤 종류의 동적 데이터를 나타낼 수 있을 만큼 보편적이어서, 네트워크 호출을 하거나, 사용자 제스처에 반응하거나, 화면에 데이터를 표시하는 것과 같은 앱의 어떤 작업도 Combine 퍼블리셔를 사용하여 처리할 수 있어.

퍼블리셔를 사용하면, 작업에 필요한 도구를 계속해서 툴박스에서 찾을 필요가 없어져. 대리자를 추가하거나 완료 콜백을 주입하는 것과 같은 일을 할 때마다, 그냥 퍼블리셔를 사용할 수 있거든.

퍼블리셔의 가장 좋은 기능 중 하나는 내장된 오류 처리 기능이야; 오류 처리는 필요하다고 느낄 때 선택적으로 맨 끝에 추가하는 것이 아니라 기본적으로 제공돼.

앞서 다이어그램에서 볼 수 있듯이, Publisher 프로토콜은 두 가지 타입에 대해 제네릭이야:
- **Publisher.Output**은 퍼블리셔의 출력 값 타입이야. 예를 들어 퍼블리셔가 Int로 특수화되어 있다면, String이나 Date 값을 발행할 수 없어.
- **Publisher.Failure**는 퍼블리셔가 실패했을 때 발생할 수 있는 오류 타입이야. 퍼블리셔가 절대 실패할 수 없다면, Never 실패 타입을 사용하여 명시할 수 있어.

특정 퍼블리셔를 구독할 때, 그 퍼블리셔로부터 어떤 값들을 기대해야 하는지 그리고 어떤 오류로 실패할 수 있는지를 알 수 있어.
#### Operators
퍼블리셔 프로토콜에 선언된 메서드인 오퍼레이터들은 동일한 퍼블리셔나 새로운 퍼블리셔를 반환해. 이것은 매우 유용해, 왜냐하면 오퍼레이터들을 연달아 호출하면서 효과적으로 연결할 수 있거든.

이러한 메서드들을 '오퍼레이터'라고 부르는데, 그들은 매우 분리되어 있고 조합이 가능해서, 단일 구독의 실행에 대해 매우 복잡한 로직을 구현하기 위해 결합될 수 있어. 정말로 흥미로운 점은 오퍼레이터들이 퍼즐 조각처럼 꽉 맞춰진다는 거야. 잘못된 순서로 놓일 수 없고, 하나의 출력이 다음 입력 타입과 맞지 않으면 서로 맞물릴 수 없어:

![](Pasted%20image%2020240703230110.png)
명확하고 결정적인 방식으로, 각각의 비동기 추상화 작업 조각들의 순서를 올바른 입력/출력 타입과 내장된 오류 처리와 함께 정의할 수 있어. 거의 믿기 어려울 정도로 완벽해!

덧붙여서, 오퍼레이터는 항상 입력과 출력을 가지는데, 이것을 흔히 상류(upstream)와 하류(downstream)라고 해. 이것은 공유된 상태를 피할 수 있게 해주는데(우리가 앞서 논의한 핵심 문제 중 하나야).
오퍼레이터들은 받은 데이터를 가지고 작업을 수행하고 그 결과를 체인의 다음 오퍼레이터에게 제공해. 이는 다른 비동기 실행 중인 코드 조각이 "끼어들어" 네가 작업 중인 데이터를 변경할 수 없다는 것을 의미해.
#### Subscribers
구독 체인의 끝에 도달하게 되는데: 모든 구독은 구독자로 끝나. 일반적으로 구독자들은 발행된 출력이나 완료 이벤트로 "무언가"를 해.

![](Pasted%20image%2020240703232401.png)

현재 Combine은 데이터 스트림을 다루기 쉽게 만드는 두 가지 내장 구독자를 제공해:

- **Sink 구독자**는 출력 값과 완료 이벤트를 받을 수 있는 클로저와 함께 코드를 제공할 수 있게 해줘. 거기서 네 마음대로 받은 이벤트로 무엇이든 할 수 있어.
- **Assign 구독자**는 사용자 정의 코드 없이도 결과 출력을 데이터 모델의 특정 속성이나 UI 컨트롤에 바로 연결하여 화면에 데이터를 직접 표시할 수 있게 해줘. 이는 키 경로를 통해 이루어져.

데이터에 대한 다른 요구 사항이 있다면, 퍼블리셔를 만드는 것보다 사용자 정의 구독자를 만드는 것이 더 쉬워. Combine은 너만의 사용자 정의 도구를 만들 수 있게 해주는 매우 간단한 프로토콜 세트를 사용해, 워크샵이 네 작업에 맞는 올바른 도구를 제공하지 않을 때 언제든지 구축할 수 있어.

#### Subscription

구독자를 구독 체인 끝에 추가하면, 체인의 시작부터 있는 퍼블리셔를 "활성화"시켜. 이건 알아둬야 할 중요하고도 흥미로운 세부사항인데, 구독자가 없으면 퍼블리셔가 값을 전혀 내보내지 않거든.

구독은 한 번만 비동기 이벤트 체인을 선언하고 나면 다시 생각할 필요가 없어서 정말 멋진 개념이야.

만약 네 앱의 로직을 전부 구독으로 설명하고 나면, 데이터를 밀고 당기거나 이 객체나 저 객체를 콜백할 필요 없이 시스템이 알아서 모든 걸 실행하게 둘 수 있어.

![](Pasted%20image%2020240703233438.png)

구독 코드가 성공적으로 컴파일되고 사용자 정의 코드에 로직 문제가 없다면, 끝난 거야! 설계대로 구독은 비동기적으로 "작동"해. 예를 들어 사용자가 제스처를 하거나 타이머가 울리는 등의 이벤트가 발생할 때마다 퍼블리셔를 깨워.

더 좋은 건, Combine에서 제공하는 Cancellable 프로토콜 덕분에 구독을 특별히 메모리 관리할 필요가 없다는 거야. 시스템에서 제공하는 구독자 모두 Cancellable을 준수하니까, 구독 코드(예를 들어 전체 퍼블리셔, 오퍼레이터 및 구독자 체인)는 Cancellable 객체를 반환해. 이 객체를 메모리에서 해제하면, 전체 구독이 취소되고 그 자원도 메모리에서 해제돼.

예를 들어, 구독의 수명을 뷰 컨트롤러의 속성에 저장함으로써 쉽게 "바인딩"할 수 있어. 이렇게 하면 사용자가 뷰 컨트롤러를 뷰 스택에서 제거할 때 그 속성들이 초기화되고 구독도 취소되거든.

또는 이 과정을 자동화하고 싶다면, 너의 타입에 `[AnyCancellable]` 컬렉션 속성을 만들어서 원하는 만큼 구독을 넣으면 돼. 속성이 메모리에서 해제될 때 모든 구독이 자동으로 취소되고 해제될 거야.

보다시피 배울 건 많지만, 자세히 설명하면 모든 게 논리적이야. 그리고 이게 바로 다음 장에서 할 계획이야 — 책이 끝날 때까지 천천히 하지만 꾸준히 너를 Combine 영웅으로 만들기.