* 브릿지는 소위 **데카르트 곱 복잡도** 폭발을 방지한다.
* 예)
	* ThreadScheduler 라는 기본 클래스가 있다고 가정해보자.
	* ThreadScheduler는 선점형이거나 협력적일 수 있으며 
	* Windows, linux에서도 실행될 수 있다.
	* WindowsPTS, UnixPTS, WindowsPTS, UnixPTS를 구현하기로 결정했다면 2x2 시나리오로 끝낼 수 있다.
* 브릿지 패턴은 바로 이 전체 엔터티 폭발을 실제로 방지하는 것이다.

ThreadScheduler는 platormScheduler(UnixScheduler, WindowsScheduler)를 채택하여 
PreemptiveThreadScheduler, CooperativeThreadScheduler를 만들 수 있다.

이것이 브리지의 일반적인 구현이다.

브릿지는 구현에서 인터페이스 또는 계층 구조를 분리하는 메커니즘이다.
그리고 이 두 가지 모두 계층 구조가 될 수 있지만 하나의 큰 상속 관계에 참여할 필요는 없다.
이 경우 다른 구성 요소에 상속과 집계를 갖거나 참조만 유지할 수 있다.

## 예제를 들면서
브릿지 패턴은 매우 단순한 패턴이다.

구현과 더불어 추상화 부분까지 변경해야 한다면 브릿지 패턴을 쓰면 된다.

**장점**
* 구현과 인터페이스를 완전히 결합하지 않았기에 구현과 추상화 부분을 분리할 수 있다.
* 추상화된 부분과 실제 구현 부분을 독립적으로 확장할 수 있다.
* 추상화 부분을 구현한 구상 클래스가 바뀌어도 클라이언트에는 영향을 끼치지 않는다.

**활용법과 단점**
* 여러 플랫폼에서 사용해야 하는 그래픽스와 윈도우 처리 시스템에서 유용하게 쓰인다.
* 인터페이스와 실제 구현할 부분을 서로 다른 방식으로 변경해야 할 때 유용하게 쓴다.
* 디자인이 복잡해진다.
